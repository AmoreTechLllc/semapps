{"version":3,"file":"index.es.js","sources":["../src/fields/ImageField.js","../src/fields/ReferenceArrayField.js","../src/fields/ReferenceField.js","../src/dataHandling/FilterHandler.js","../src/dataHandling/GroupedReferenceHandler.js","../src/inputs/DateTimeInput.js","../src/inputs/ReferenceArrayInput.js","../src/inputs/ReferenceInput.js","../src/inputs/ReificationArrayInput.js","../src/dereference.js","../src/buildSparqlQuery.js","../src/dataProvider.js","../src/httpClient.js"],"sourcesContent":["import React from 'react';\nimport { ImageField as RaImageField } from 'react-admin';\n\nconst ImageField = ({ record, source, ...otherProps }) => {\n  // For the display, we need to have the URI in a src property\n  if (typeof record === 'string') record = { [source]: record };\n  return <RaImageField record={record} source={source} {...otherProps} />;\n};\n\nexport default ImageField;\n","import React from 'react';\nimport { ReferenceArrayField as RaReferenceArrayField } from 'react-admin';\n\nconst ReferenceArrayField = ({ record, source, ...otherProps }) => {\n  if (record?.[source]) {\n    if (!Array.isArray(record[source])) {\n      record[source] = [record[source]];\n    }\n    record[source] = record[source].map(i => i['@id'] || i.id || i);\n  }\n  return <RaReferenceArrayField record={record} source={source} {...otherProps} />;\n};\n\nReferenceArrayField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceArrayField;\n","import React from 'react';\nimport { ReferenceField as RaReferenceField } from 'react-admin';\n\nconst ReferenceField = ({ record, source, ...otherProps }) => {\n  if (record[source]) {\n    if (typeof record[source] === 'object') {\n      record[source] = record[source]['@id'] || record[source].id;\n    }\n  }\n  return <RaReferenceField record={record} source={source} {...otherProps} />;\n};\n\nReferenceField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceField;\n","import React, { useState, useEffect } from 'react';\nimport { ArrayField } from 'react-admin';\n\n/**\n * @example\n * <Show>\n *   <FilterHandler\n *     source=\"property\" // ex pair:organizationOfMembership\n *     filter={{\n *       'propertyToFilter':'value'\n *     }} // ex {{'pair:membershipRole':'http://localhost:3000/membership-roles/role-1'}}\n *     >\n *     <SingleFieldList>\n *    </SingleFieldList>\n *   </FilterHandler>\n * </Show>\n */\n\nconst FilterHandler = ({ children, record, filter, source, ...otherProps }) => {\n  const [filtered, setFiltered] = useState();\n  useEffect(() => {\n    if (record && source && Array.isArray(record?.[source])) {\n      const filteredData = record?.[source].filter(r => {\n        let eq = true;\n        for (const key in filter) {\n          const value = r[key];\n          if (Array.isArray(value)) {\n            if (!value.includes(filter[key])) {\n              eq = false;\n            }\n          } else {\n            if (value !== filter[key]) {\n              eq = false;\n            }\n          }\n        }\n        return eq;\n      });\n      let newRecord = {\n        ...record\n      };\n      //undefined setted if no data to obtain no render in RightLabel or equivalent\n      newRecord[source] = filteredData.length > 0 ? filteredData : undefined;\n      setFiltered(newRecord);\n    }\n  }, [record, source, filter]);\n\n  return (\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          ...otherProps,\n          record: filtered,\n          addLabel: true,\n          source\n        });\n      })}\n    </>\n  );\n};\nexport default FilterHandler;\n","import React from 'react';\nimport { useQueryWithStore } from 'react-admin';\nimport { default as FilterHandler } from './FilterHandler';\n\n/*\n * @example Label used in examples\n *  const Label = ({label, ...otherProps})=>{\n *     return <h2>{label}</h2>\n *  }\n *\n * @example show header for each group with group property thanks to groupHeader\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupHeader={({group,...otherProps}) => <Label {...otherProps} label={group['pair:label']}></Label> }\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example call chhildren with label thanks to groupLabel\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example conditional show of group if no data in source. Conditionale groupHeader is not possible because GroupedArrayField define group before filter ; need use chhildren.\n * const ConditionalSourceDefinedHandler = ({record,source,children,...otherProps})=>{\n *   if (record?.[source] && (!Array.isArray(record[source])||record[source].length>0)){\n *     return  React.Children.map(children, (child, i) => {\n *         return React.cloneElement(child, {...otherProps,record,source});\n *       })\n *   }else{\n *     return <></>\n *   }\n * }\n *\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *  <ConditionalSourceDefinedHandler>\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n *  </ConditionalSourceDefinedHandler>\n * </GroupedReferenceHandler>\n *\n *\n */\nconst GroupedReferenceHandler = ({\n  children,\n  groupReference,\n  groupLabel,\n  groupHeader,\n  filterProperty,\n  ...otherProps\n}) => {\n  const { data } = useQueryWithStore({\n    type: 'getList',\n    resource: groupReference,\n    payload: {}\n  });\n\n  return (\n    <>\n      {data?.map((data, index) => {\n        let filter = {};\n        filter[filterProperty] = data.id;\n        return (\n          <>\n            {groupHeader && groupHeader({ ...otherProps, group: data })}\n            <FilterHandler {...otherProps} filter={filter} label={data[groupLabel]}>\n              {children}\n            </FilterHandler>\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport default GroupedReferenceHandler;\n","import React from 'react';\nimport { DateTimeInput as RaDateTimeInput } from 'react-admin';\n\n/**\n * @deprecated Use the component from the @semapps/date-components instead\n */\nconst DateTimeInput = props => (\n  <RaDateTimeInput {...props} format={value => value && value.replace(' ', 'T').replace('Z', '')} />\n);\n\nexport default DateTimeInput;\n","import React from 'react';\nimport { ReferenceArrayInput as RaReferenceArrayInput, useResourceContext } from 'react-admin';\n\nconst ReferenceArrayInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceArrayInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // if the linked field value is not an array, turns it into an array.\n        // Necessary as JSON-LD are sometimes arrays, sometimes not (when there is one value)\n        // and the ReferenceArrayInput component only accept arrays\n        if (!Array.isArray(value)) value = [value];\n        // If a format prop was defined, apply it to the array\n        if (props.format) value = props.format(value);\n        // If the values are objects with @id field, turn it to a simple string\n        return value.map(v => (typeof v === 'object' ? v.id || v['@id'] : v));\n      }}\n    />\n  );\n};\n\nexport default ReferenceArrayInput;\n","import React from 'react';\nimport { ReferenceInput as RaReferenceInput, useResourceContext } from 'react-admin';\n\nconst ReferenceInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // If a format prop was defined, apply it\n        if (props.format) value = props.format(value);\n        // If the value is an object with an @id field, return the uri\n        return typeof value === 'object' ? value.id || value['@id'] : value;\n      }}\n    />\n  );\n};\n\nexport default ReferenceInput;\n","import React, { useEffect, useState } from 'react';\nimport { ArrayInput, SimpleFormIterator, TextInput } from 'react-admin';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useReferenceInputStyles = makeStyles({\n  form: {\n    display: 'flex'\n  },\n  input: {\n    paddingRight: '20px'\n  }\n});\n\nconst useHideInputStyles = makeStyles({\n  root: {\n    display: 'none'\n  }\n});\n\nconst ReificationArrayInput = props => {\n  const { reificationClass, children, ...otherProps } = props;\n  const flexFormClasses = useReferenceInputStyles();\n  const hideInputStyles = useHideInputStyles();\n\n  return (\n    <ArrayInput {...otherProps}>\n      <SimpleFormIterator classes={{ form: flexFormClasses.form }}>\n        {React.Children.map(props.children, (child, i) => {\n          return React.cloneElement(child, {\n            className: flexFormClasses.input\n          });\n        })}\n        <TextInput className={hideInputStyles.root} source=\"type\" initialValue={reificationClass} />\n      </SimpleFormIterator>\n    </ArrayInput>\n  );\n};\n\nexport default ReificationArrayInput;\n","// Return an object in the form of predicate => parentPredicate\nconst flattenPredicate = (accumulator, predicate, parent = 'root') => {\n  if (predicate.includes('/')) {\n    const matches = predicate.split(/\\/(.+)/);\n    accumulator[matches[0]] = parent;\n    flattenPredicate(accumulator, matches[1], matches[0]);\n  } else {\n    accumulator[predicate] = parent;\n  }\n  return accumulator;\n};\n\n// Transform ontology:predicate to OntologyPredicate in order to use it as a variable name\nconst generateSparqlVarName = predicate =>\n  predicate\n    .split(':')\n    .map(s => s[0].toUpperCase() + s.slice(1))\n    .join('');\n\nexport const buildDereferenceQuery = predicates => {\n  let queries = [];\n\n  if (predicates) {\n    const flattenedPredicates = predicates.reduce((acc, predicate) => flattenPredicate(acc, predicate), {});\n\n    for (const [predicate, parent] of Object.entries(flattenedPredicates)) {\n      const varName = generateSparqlVarName(predicate);\n      const parentVarName = parent === 'root' ? '1' : generateSparqlVarName(parent);\n\n      // Group queries by parent, so that we can group WHERE triples in the same OPTIONAL tag\n      const groupKey = parent === 'root' ? predicate : parent;\n      if (!queries[groupKey]) queries[groupKey] = [];\n\n      queries[groupKey].push(`\n        ?s${parentVarName} ${predicate} ?s${varName} .\n        ?s${varName} ?p${varName} ?o${varName} .\n      `);\n    }\n  }\n\n  return {\n    construct: Object.values(queries)\n      .map(groupedQueries => Object.values(groupedQueries).join('\\n'))\n      .join('\\n'),\n    where: Object.values(queries)\n      .map(groupedQueries => `OPTIONAL { ${Object.values(groupedQueries).join('\\n')} }`)\n      .join('\\n')\n  };\n};\n\nexport const getEmbedFrame = paths => {\n  let embedFrame = {},\n    predicates;\n  if (paths) {\n    for (let path of paths) {\n      if (path.includes('/')) {\n        predicates = path.split('/').reverse();\n      } else {\n        predicates = [path];\n      }\n      embedFrame = {\n        ...embedFrame,\n        ...predicates.reduce(\n          (accumulator, predicate) => ({\n            [predicate]: {\n              '@embed': '@last',\n              ...accumulator\n            }\n          }),\n          {}\n        )\n      };\n    }\n    return embedFrame;\n  }\n};\n","import { buildDereferenceQuery } from './dereference';\n\nconst getPrefixRdf = ontologies => {\n  return ontologies.map(ontology => `PREFIX ${ontology.prefix}: <${ontology.url}>`).join('\\n');\n};\n\nconst buildSparqlQuery = ({ types, params: { filter }, dereference, ontologies }) => {\n  let searchWhereQuery = '',\n    filterWhereQuery = '';\n\n  if (filter) {\n    if (filter.q && filter.q.length > 0) {\n      searchWhereQuery += `\n      {\n        SELECT ?s1\n        WHERE {\n          ?s1 ?p1 ?o1 .\n          FILTER regex(lcase(str(?o1)), \"${filter.q.toLowerCase()}\")\n          FILTER NOT EXISTS {?s1 a ?o1}\n        }\n      }\n      `;\n      delete filter.q;\n    }\n    Object.keys(filter).forEach(predicate => {\n      if (filter[predicate]) {\n        const object = filter[predicate].startsWith('http') ? `<${filter[predicate]}>` : filter[predicate];\n        filterWhereQuery += `?s1 ${predicate} ${object} .`;\n      }\n    });\n  }\n\n  const dereferenceQuery = buildDereferenceQuery(dereference);\n\n  return `\n    ${getPrefixRdf(ontologies)}\n    CONSTRUCT {\n      ?s1 ?p2 ?o2 .\n      ${dereferenceQuery.construct}\n    }\n    WHERE {\n      ${filterWhereQuery}\n      ?s1 a ?type .\n      FILTER( ?type IN (${types.join(', ')}) ) .\n      FILTER( (isIRI(?s1)) ) .\n      ${searchWhereQuery}\n      ${dereferenceQuery.where}\n      ?s1 ?p2 ?o2 .\n    }\n  `;\n};\n\nexport default buildSparqlQuery;\n","import jsonld from 'jsonld';\nimport buildSparqlQuery from './buildSparqlQuery';\nimport { getEmbedFrame } from './dereference';\nconst createSlug = require('speakingurl');\n\nconst buildJsonContext = ontologies => {\n  let pattern = {};\n  ontologies.forEach(ontology => (pattern[ontology.prefix] = ontology.url));\n  return pattern;\n};\n\nconst isFile = o => o && o.rawFile && o.rawFile instanceof File;\n\nconst getSlugWithExtension = fileName => {\n  let fileExtension = '';\n  let splitFileName = fileName.split('.');\n  if (splitFileName.length > 1) {\n    fileExtension = splitFileName.pop();\n    fileName = splitFileName.join('.');\n  }\n  return createSlug(fileName, { lang: 'fr' }) + '.' + fileExtension;\n};\n\nconst isType = (type, resource) => {\n  const resourceType = resource.type || resource['@type'];\n  return Array.isArray(resourceType) ? resourceType.includes(type) : resourceType === type;\n};\n\nconst dataProvider = ({\n  sparqlEndpoint,\n  httpClient,\n  resources,\n  ontologies,\n  jsonContext,\n  uploadsContainerUri,\n  returnFailedResources = false\n}) => {\n  const uploadFile = async rawFile => {\n    if (!uploadsContainerUri) throw new Error('No uploadsContainerUri defined for the data provider');\n\n    const response = await httpClient(uploadsContainerUri, {\n      method: 'POST',\n      body: rawFile,\n      headers: new Headers({\n        // We must sluggify the file name, because we can't use non-ASCII characters in the header\n        // However we keep the extension apart (if it exists) so that it is not replaced with a -\n        // TODO let the middleware guess the extension based on the content type\n        Slug: getSlugWithExtension(rawFile.name),\n        'Content-Type': rawFile.type\n      })\n    });\n\n    if (response.status === 201) {\n      return response.headers.get('Location');\n    }\n  };\n\n  /*\n   * Look for raw files in the resource data.\n   * If there are any, upload them and replace the file by its URL.\n   */\n  const uploadAllFiles = async resource => {\n    for (let property in resource) {\n      if (resource.hasOwnProperty(property)) {\n        if (Array.isArray(resource[property])) {\n          for (let i = 0; i < resource[property].length; i++) {\n            if (isFile(resource[property][i])) {\n              resource[property][i] = await uploadFile(resource[property][i].rawFile);\n            }\n          }\n        } else {\n          if (isFile(resource[property])) {\n            resource[property] = await uploadFile(resource[property].rawFile);\n          }\n        }\n      }\n    }\n    return resource;\n  };\n\n  const ExecuteSparql = async (resourceId, params) => {\n    const sparqlQuery = buildSparqlQuery({\n      types: resources[resourceId].types,\n      params: { ...params, filter: { ...resources[resourceId].filter, ...params.filter } },\n      dereference: resources[resourceId].dereference,\n      ontologies\n    });\n\n    const { json } = await httpClient(sparqlEndpoint, {\n      method: 'POST',\n      body: sparqlQuery\n    });\n\n    const frame = {\n      '@context': jsonContext || buildJsonContext(ontologies),\n      '@type': resources[resourceId].types,\n      // Embed only what we explicitly asked to dereference\n      // Otherwise we may have same-type resources embedded in other resources\n      '@embed': '@never',\n      ...getEmbedFrame(resources[resourceId].dereference)\n    };\n\n    // omitGraph option force results to be in a @graph, even if we have a single result\n    const compactJson = await jsonld.frame(json, frame, { omitGraph: false });\n\n    if (Object.keys(compactJson).length === 1) {\n      // If we have only the context, it means there is no match\n      return { data: [], total: 0 };\n    } else {\n      // Add id in addition to @id, as this is what React-Admin expects\n      let returnData = compactJson['@graph'].map(item => {\n        item.id = item.id || item['@id'];\n        return item;\n      });\n\n      if (params.sort) {\n        returnData = returnData.sort((a, b) => {\n          if (a[params.sort.field] && b[params.sort.field]) {\n            if (params.sort.order === 'ASC') {\n              return a[params.sort.field].localeCompare(b[params.sort.field]);\n            } else {\n              return b[params.sort.field].localeCompare(a[params.sort.field]);\n            }\n          } else {\n            return true;\n          }\n        });\n      }\n      if (params.pagination) {\n        returnData = returnData.slice(\n          (params.pagination.page - 1) * params.pagination.perPage,\n          params.pagination.page * params.pagination.perPage\n        );\n      }\n\n      return { data: returnData, total: compactJson['@graph'].length };\n    }\n  };\n\n  return {\n    getList: async (resourceId, params) => {\n      if (!resources[resourceId]) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n      if (params.id || params['@id'] || resources[resourceId].fetchContainer) {\n        const url = params.id || params['@id'] || resources[resourceId].containerUri;\n        let { json } = await httpClient(url);\n\n        if (isType('ldp:Container', json)) {\n          /*\n           * LDP Container\n           */\n          let returnData = json['ldp:contains'].map(item => {\n            item.id = item.id || item['@id'];\n            return item;\n          });\n\n          // Apply filter to results\n          if (params.filter) {\n            // Remove search params from filter\n            if (params.filter.q) {\n              delete params.filter.q;\n            }\n            if (Object.keys(params.filter).length > 0) {\n              returnData = returnData.filter(resource =>\n                Object.entries(params.filter).some(([k, v]) =>\n                  Array.isArray(resource[k]) ? resource[k].includes(v) : resource[k] === v\n                )\n              );\n            }\n          }\n\n          if (params.sort) {\n            returnData = returnData.sort((a, b) => {\n              if (a[params.sort.field] && b[params.sort.field]) {\n                if (params.sort.order === 'ASC') {\n                  return a[params.sort.field].localeCompare(b[params.sort.field]);\n                } else {\n                  return b[params.sort.field].localeCompare(a[params.sort.field]);\n                }\n              } else {\n                return true;\n              }\n            });\n          }\n          if (params.pagination) {\n            returnData = returnData.slice(\n              (params.pagination.page - 1) * params.pagination.perPage,\n              params.pagination.page * params.pagination.perPage\n            );\n          }\n\n          return { data: returnData, total: json['ldp:contains'].length };\n        } else {\n          /*\n           * ActivityPub collection\n           */\n\n          // If the collection is split amongst several pages, get the first page\n          if (json.first) {\n            const result = await httpClient(json.first);\n            json = result.json;\n          }\n\n          const listProperty = ['as:orderedItems', 'orderedItems', 'as:items', 'items'].find(p => json[p]);\n          if (!listProperty) return { data: [], total: 0 };\n\n          // TODO fetch several pages depending on params.pagination\n\n          let returnData = json[listProperty].map(item => {\n            item.id = item.id || item['@id'];\n            return item;\n          });\n\n          return { data: returnData, total: json.totalItems };\n        }\n      } else {\n        return await ExecuteSparql(resourceId, params);\n        // OTHER METHOD: FETCH ONLY RESOURCES URIs AND FETCH THEM INDEPENDENTLY\n        // TODO compare the performance of the two methods, and eventually allow both of them\n        //\n        // const sparqlQuery = buildSparqlUriQuery({\n        //   types: resources[resourceId].types,\n        //   params: { ...params, filter: { ...resources[resourceId].filter, ...params.filter } },\n        //   ontologies\n        // });\n        //\n        // let { json } = await httpClient(sparqlEndpoint, {\n        //   method: 'POST',\n        //   body: sparqlQuery\n        // });\n        //\n        // const total = json.length;\n        //\n        // if (params.pagination) {\n        //   json = json.slice(\n        //     (params.pagination.page - 1) * params.pagination.perPage,\n        //     params.pagination.page * params.pagination.perPage\n        //   );\n        // }\n        //\n        // let data = await Promise.allSettled(\n        //   json.map(result => httpClient(result.resource.value).then(result => result.json))\n        // );\n        //\n        // // Ignore resources we were not able to fetch\n        // data = data.filter(r => r.status === 'fulfilled').map(r => r.value);\n        //\n        // return { data, total };\n      }\n    },\n    getOne: async (resourceId, params) => {\n      if (!resources[resourceId]) {\n        Error(`Resource ${resourceId} is not mapped in resources file`);\n      }\n      const dataModel = resources[resourceId];\n\n      let { json } = await httpClient(params.id);\n      json.id = json.id || json['@id'];\n      // TODO compact only if remote context is different from local context\n      const compactJson = await jsonld.compact(json, jsonContext || buildJsonContext(ontologies));\n      // transform single value into array concidering forceArray predicates\n      if (dataModel.forceArray) {\n        for (const forceArrayItem of dataModel.forceArray) {\n          if (compactJson[forceArrayItem] && !Array.isArray(compactJson[forceArrayItem])) {\n            compactJson[forceArrayItem] = [compactJson[forceArrayItem]];\n          }\n        }\n      }\n      return { data: compactJson };\n    },\n    getMany: async (resourceId, params) => {\n      let returnData = [];\n\n      for (let id of params.ids) {\n        id = typeof id === 'object' ? id['@id'] : id;\n\n        try {\n          let { json } = await httpClient(id);\n          json.id = id;\n          returnData.push(json);\n        } catch (e) {\n          // Catch if one resource fails to load\n          // Otherwise no references will be show if only one is missing\n          // See https://github.com/marmelab/react-admin/issues/5190\n          if (returnFailedResources) {\n            // Return only the ID of the resource\n            returnData.push({ id });\n          } else {\n            // Do nothing. The resource will not appear in the results.\n          }\n        }\n      }\n\n      return { data: returnData };\n    },\n    getManyReference: async (resourceId, params) => {\n      params.filter = { ...params.filter, [params.target]: params.id };\n      return await ExecuteSparql(resourceId, params);\n    },\n    create: async (resourceId, params) => {\n      if (!resources[resourceId]) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n      const { slugField, containerUri, types } = resources[resourceId];\n      const headers = new Headers();\n\n      if (slugField) {\n        headers.set(\n          'Slug',\n          Array.isArray(slugField) ? slugField.map(f => params.data[f]).join(' ') : params.data[slugField]\n        );\n      }\n\n      // Upload files, if there are any\n      params.data = await uploadAllFiles(params.data);\n\n      const { headers: responseHeaders } = await httpClient(containerUri, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          '@context': jsonContext || buildJsonContext(ontologies),\n          '@type': types,\n          ...params.data\n        })\n      });\n\n      // Retrieve newly-created resource\n      const resourceUri = responseHeaders.get('Location');\n      let { json } = await httpClient(resourceUri);\n      json.id = json.id || json['@id'];\n      return { data: json };\n    },\n    update: async (resourceId, params) => {\n      // Upload files, if there are any\n      params.data = await uploadAllFiles(params.data);\n      await httpClient(params.id, {\n        method: 'PUT',\n        body: JSON.stringify({\n          '@context': jsonContext || buildJsonContext(ontologies),\n          ...params.data\n        })\n      });\n\n      return { data: params.data };\n    },\n    updateMany: (resourceId, params) => {\n      throw new Error('updateMany is not implemented yet');\n    },\n    delete: async (resourceId, params) => {\n      await httpClient(params.id, {\n        method: 'DELETE'\n      });\n      return { data: { id: params.id } };\n    },\n    deleteMany: async (resourceId, params) => {\n      let ids = [];\n      for (let id of params.ids) {\n        try {\n          await httpClient(id, {\n            method: 'DELETE'\n          });\n          ids.push(id);\n        } catch (e) {}\n      }\n      return { data: ids };\n    }\n  };\n};\n\nexport default dataProvider;\n","import { fetchUtils } from 'react-admin';\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) options.headers = new Headers();\n\n  switch (options.method) {\n    case 'POST':\n    case 'PATCH':\n    case 'PUT':\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      if (!options.headers.has('Content-Type')) options.headers.set('Content-Type', 'application/ld+json');\n      break;\n\n    case 'DELETE':\n      break;\n\n    case 'GET':\n    default:\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      break;\n  }\n\n  const token = localStorage.getItem('token');\n  if (token) options.headers.set('Authorization', `Bearer ${token}`);\n\n  return fetchUtils.fetchJson(url, options);\n};\n\nexport default httpClient;\n"],"names":["ImageField","record","source","otherProps","React","RaImageField","ReferenceArrayField","Array","isArray","map","i","id","RaReferenceArrayField","defaultProps","addLabel","ReferenceField","_typeof","RaReferenceField","FilterHandler","children","filter","useState","filtered","setFiltered","useEffect","filteredData","r","eq","key","value","includes","newRecord","length","undefined","Children","child","cloneElement","GroupedReferenceHandler","groupReference","groupLabel","groupHeader","filterProperty","data","useQueryWithStore","type","resource","payload","index","group","label","DateTimeInput","props","RaDateTimeInput","format","replace","ReferenceArrayInput","useResourceContext","RaReferenceArrayInput","v","ReferenceInput","RaReferenceInput","useReferenceInputStyles","makeStyles","form","display","input","paddingRight","useHideInputStyles","root","ReificationArrayInput","reificationClass","flexFormClasses","hideInputStyles","ArrayInput","SimpleFormIterator","classes","className","TextInput","initialValue","generateSparqlVarName","predicate","split","s","toUpperCase","slice","join","getEmbedFrame","paths","predicates","embedFrame","path","reverse","reduce","accumulator","buildSparqlQuery","types","params","dereference","ontologies","searchWhereQuery","filterWhereQuery","q","toLowerCase","Object","keys","forEach","object","startsWith","dereferenceQuery","queries","flattenedPredicates","acc","flattenPredicate","parent","matches","entries","varName","parentVarName","groupKey","push","construct","values","groupedQueries","where","buildDereferenceQuery","ontology","prefix","url","getPrefixRdf","createSlug","require","buildJsonContext","pattern","isFile","o","rawFile","File","dataProvider","sparqlEndpoint","httpClient","resources","jsonContext","uploadsContainerUri","returnFailedResources","uploadFile","Error","method","body","headers","Headers","Slug","fileName","name","fileExtension","splitFileName","pop","lang","response","status","get","uploadAllFiles","property","hasOwnProperty","ExecuteSparql","resourceId","sparqlQuery","json","frame","jsonld","omitGraph","compactJson","total","returnData","item","sort","a","b","field","order","localeCompare","pagination","page","perPage","getList","fetchContainer","containerUri","resourceType","some","k","first","result","listProperty","find","p","totalItems","getOne","dataModel","compact","forceArray","forceArrayItem","getMany","ids","getManyReference","target","create","slugField","set","f","JSON","stringify","responseHeaders","resourceUri","update","updateMany","deleteMany","options","has","token","localStorage","getItem","fetchUtils","fetchJson"],"mappings":"srHAGMA,EAAa,gBAAGC,IAAAA,OAAQC,IAAAA,OAAWC,iCAEjB,iBAAXF,IAAqBA,OAAYC,EAASD,IAC9CG,gBAACC,KAAaJ,OAAQA,EAAQC,OAAQA,GAAYC,KCHrDG,EAAsB,gBAAGL,IAAAA,OAAQC,IAAAA,OAAWC,kCAC5CF,MAAAA,SAAAA,EAASC,MACNK,MAAMC,QAAQP,EAAOC,MACxBD,EAAOC,GAAU,CAACD,EAAOC,KAE3BD,EAAOC,GAAUD,EAAOC,GAAQO,KAAI,SAAAC,UAAKA,EAAE,QAAUA,EAAEC,IAAMD,MAExDN,gBAACQ,KAAsBX,OAAQA,EAAQC,OAAQA,GAAYC,KAGpEG,EAAoBO,aAAe,CACjCC,UAAU,OCXNC,EAAiB,gBAAGd,IAAAA,OAAQC,IAAAA,OAAWC,kCACvCF,EAAOC,IACqB,WAA1Bc,EAAOf,EAAOC,MAChBD,EAAOC,GAAUD,EAAOC,GAAQ,QAAUD,EAAOC,GAAQS,IAGtDP,gBAACa,KAAiBhB,OAAQA,EAAQC,OAAQA,GAAYC,KAG/DY,EAAeF,aAAe,CAC5BC,UAAU,OCKNI,EAAgB,gBAAGC,IAAAA,SAAUlB,IAAAA,OAAQmB,IAAAA,OAAQlB,IAAAA,OAAWC,mDAC5BkB,OAAzBC,OAAUC,cACjBC,GAAU,cACJvB,GAAUC,GAAUK,MAAMC,QAAQP,MAAAA,SAAAA,EAASC,IAAU,KACjDuB,EAAexB,MAAAA,SAAAA,EAASC,GAAQkB,QAAO,SAAAM,OACvCC,GAAK,MACJ,IAAMC,KAAOR,EAAQ,KAClBS,EAAQH,EAAEE,GACZrB,MAAMC,QAAQqB,GACXA,EAAMC,SAASV,EAAOQ,MACzBD,GAAK,GAGHE,IAAUT,EAAOQ,KACnBD,GAAK,UAIJA,KAELI,OACC9B,GAGL8B,EAAU7B,GAAUuB,EAAaO,OAAS,EAAIP,OAAeQ,EAC7DV,EAAYQ,MAEb,CAAC9B,EAAQC,EAAQkB,IAGlBhB,gCACGA,EAAM8B,SAASzB,IAAIU,GAAU,SAACgB,EAAOzB,UAC7BN,EAAMgC,aAAaD,SACrBhC,OACHF,OAAQqB,EACRR,UAAU,EACVZ,OAAAA,UCcJmC,EAA0B,gBAC9BlB,IAAAA,SACAmB,IAAAA,eACAC,IAAAA,WACAC,IAAAA,YACAC,IAAAA,eACGtC,iFAEKuC,EAASC,EAAkB,CACjCC,KAAM,UACNC,SAAUP,EACVQ,QAAS,KAHHJ,YAONtC,gCACGsC,MAAAA,SAAAA,EAAMjC,KAAI,SAACiC,EAAMK,OACZ3B,EAAS,UACbA,EAAOqB,GAAkBC,EAAK/B,GAE5BP,gCACGoC,GAAeA,SAAiBrC,OAAY6C,MAAON,KACpDtC,gBAACc,OAAkBf,GAAYiB,OAAQA,EAAQ6B,MAAOP,EAAKH,KACxDpB,SCrFT+B,EAAgB,SAAAC,UACpB/C,gBAACgD,OAAoBD,GAAOE,OAAQ,SAAAxB,UAASA,GAASA,EAAMyB,QAAQ,IAAK,KAAKA,QAAQ,IAAK,SCJvFC,EAAsB,SAAAJ,OACpBN,EAAWW,EAAmB,WAElCpD,gBAACqD,OACKN,GACJN,SAAUA,EACVQ,OAAQ,SAAAxB,UAEDA,GAIAtB,MAAMC,QAAQqB,KAAQA,EAAQ,CAACA,IAEhCsB,EAAME,SAAQxB,EAAQsB,EAAME,OAAOxB,IAEhCA,EAAMpB,KAAI,SAAAiD,SAAmB,WAAb1C,EAAO0C,GAAiBA,EAAE/C,IAAM+C,EAAE,OAASA,MAR/C7B,OCRrB8B,EAAiB,SAAAR,OACfN,EAAWW,EAAmB,WAElCpD,gBAACwD,OACKT,GACJN,SAAUA,EACVQ,OAAQ,SAAAxB,UAEDA,GAEDsB,EAAME,SAAQxB,EAAQsB,EAAME,OAAOxB,IAEf,WAAjBb,EAAOa,GAAqBA,EAAMlB,IAAMkB,EAAM,OAASA,GAJ3CA,OCPrBgC,EAA0BC,EAAW,CACzCC,KAAM,CACJC,QAAS,QAEXC,MAAO,CACLC,aAAc,UAIZC,EAAqBL,EAAW,CACpCM,KAAM,CACJJ,QAAS,UAIPK,EAAwB,SAAAlB,OACpBmB,EAA8CnB,EAA9CmB,iBAA+BnE,GAAegD,EAA5BhC,WAA4BgC,oCAChDoB,EAAkBV,IAClBW,EAAkBL,WAGtB/D,gBAACqE,EAAetE,EACdC,gBAACsE,GAAmBC,QAAS,CAAEZ,KAAMQ,EAAgBR,OAClD3D,EAAM8B,SAASzB,IAAI0C,EAAMhC,UAAU,SAACgB,EAAOzB,UACnCN,EAAMgC,aAAaD,EAAO,CAC/ByC,UAAWL,EAAgBN,WAG/B7D,gBAACyE,GAAUD,UAAWJ,EAAgBJ,KAAMlE,OAAO,OAAO4E,aAAcR,OCnB1ES,EAAwB,SAAAC,UAC5BA,EACGC,MAAM,KACNxE,KAAI,SAAAyE,UAAKA,EAAE,GAAGC,cAAgBD,EAAEE,MAAM,MACtCC,KAAK,KAiCGC,EAAgB,SAAAC,OAEzBC,EADEC,EAAa,MAEbF,EAAO,WACQA,kCAAO,KAAfG,UAELF,EADEE,EAAK5D,SAAS,KACH4D,EAAKT,MAAM,KAAKU,UAEhB,CAACD,GAEhBD,SACKA,GACAD,EAAWI,QACZ,SAACC,EAAab,eACXA,cACW,SACPa,MAGP,2CAICJ,ICnELK,EAAmB,gBAAGC,IAAAA,MAAiB3E,IAAV4E,OAAU5E,OAAU6E,IAAAA,YAAaC,IAAAA,WAC9DC,EAAmB,GACrBC,EAAmB,GAEjBhF,IACEA,EAAOiF,GAAKjF,EAAOiF,EAAErE,OAAS,IAChCmE,+HAKqC/E,EAAOiF,EAAEC,gGAKvClF,EAAOiF,GAEhBE,OAAOC,KAAKpF,GAAQqF,SAAQ,SAAAzB,MACtB5D,EAAO4D,GAAY,KACf0B,EAAStF,EAAO4D,GAAW2B,WAAW,mBAAcvF,EAAO4D,QAAgB5D,EAAO4D,GACxFoB,iBAA2BpB,cAAa0B,iBAKxCE,EDb6B,SAAApB,OAC/BqB,EAAU,MAEVrB,UACIsB,EAAsBtB,EAAWI,QAAO,SAACmB,EAAK/B,UAtB/B,SAAnBgC,EAAoBnB,EAAab,OAAWiC,yDAAS,UACrDjC,EAAUlD,SAAS,KAAM,KACrBoF,EAAUlC,EAAUC,MAAM,UAChCY,EAAYqB,EAAQ,IAAMD,EAC1BD,EAAiBnB,EAAaqB,EAAQ,GAAIA,EAAQ,SAElDrB,EAAYb,GAAaiC,SAEpBpB,EAc6DmB,CAAiBD,EAAK/B,KAAY,UAElEuB,OAAOY,QAAQL,kBAAsB,iBAA3D9B,OAAWiC,OACfG,EAAUrC,EAAsBC,GAChCqC,EAA2B,SAAXJ,EAAoB,IAAMlC,EAAsBkC,GAGhEK,EAAsB,SAAXL,EAAoBjC,EAAYiC,EAC5CJ,EAAQS,KAAWT,EAAQS,GAAY,IAE5CT,EAAQS,GAAUC,2BACZF,cAAiBrC,gBAAeoC,2BAChCA,gBAAaA,gBAAaA,uBAK7B,CACLI,UAAWjB,OAAOkB,OAAOZ,GACtBpG,KAAI,SAAAiH,UAAkBnB,OAAOkB,OAAOC,GAAgBrC,KAAK,SACzDA,KAAK,MACRsC,MAAOpB,OAAOkB,OAAOZ,GAClBpG,KAAI,SAAAiH,8BAAgCnB,OAAOkB,OAAOC,GAAgBrC,KAAK,eACvEA,KAAK,OCdeuC,CAAsB3B,yBA9B5B,SAAAC,UACZA,EAAWzF,KAAI,SAAAoH,0BAAsBA,EAASC,qBAAYD,EAASE,YAAQ1C,KAAK,MAgCnF2C,CAAa9B,4DAGXU,EAAiBY,iDAGjBpB,4DAEkBL,EAAMV,KAAK,8DAE7Bc,qBACAS,EAAiBe,2CC3CnBM,EAAaC,QAAQ,eAErBC,EAAmB,SAAAjC,OACnBkC,EAAU,UACdlC,EAAWO,SAAQ,SAAAoB,UAAaO,EAAQP,EAASC,QAAUD,EAASE,OAC7DK,GAGHC,EAAS,SAAAC,UAAKA,GAAKA,EAAEC,SAAWD,EAAEC,mBAAmBC,MAiBrDC,EAAe,gCACnBC,IAAAA,eACAC,IAAAA,WACAC,IAAAA,UACA1C,IAAAA,WACA2C,IAAAA,YACAC,IAAAA,wBACAC,sBAAAA,gBAEMC,8CAAa,WAAMT,4FAClBO,wBAA2B,IAAIG,MAAM,+EAEnBN,EAAWG,EAAqB,CACrDI,OAAQ,OACRC,KAAMZ,EACNa,QAAS,IAAIC,QAAQ,CAInBC,MAlCqBC,EAkCMhB,EAAQiB,KAjCrCC,OAAAA,EACAC,OAAAA,EADAD,EAAgB,GAChBC,EAAgBH,EAAStE,MAAM,KAC/ByE,EAAc1H,OAAS,IACzByH,EAAgBC,EAAcC,MAC9BJ,EAAWG,EAAcrE,KAAK,MAEzB4C,EAAWsB,EAAU,CAAEK,KAAM,OAAU,IAAMH,kBA4B9BlB,EAAQ3F,mBAIJ,OAZlBiH,UAYOC,gDACJD,EAAST,QAAQW,IAAI,8CAxCL,IAAAR,EACvBE,EACAC,iEA8CEM,8CAAiB,WAAMnH,wHACNA,oDAAZoH,cACHpH,EAASqH,eAAeD,wBACtB1J,MAAMC,QAAQqC,EAASoH,qBAChBvJ,EAAI,cAAGA,EAAImC,EAASoH,GAAUjI,6BACjCqG,EAAOxF,EAASoH,GAAUvJ,sCACEsI,EAAWnG,EAASoH,GAAUvJ,GAAG6H,iBAA/D1F,EAASoH,GAAUvJ,kBAFwBA,uDAM3C2H,EAAOxF,EAASoH,sCACSjB,EAAWnG,EAASoH,GAAU1B,iBAAzD1F,EAASoH,kEAKVpH,qGAGHsH,8CAAgB,WAAOC,EAAYpE,0GACjCqE,EAAcvE,EAAiB,CACnCC,MAAO6C,EAAUwB,GAAYrE,MAC7BC,cAAaA,OAAQ5E,cAAawH,EAAUwB,GAAYhJ,QAAW4E,EAAO5E,UAC1E6E,YAAa2C,EAAUwB,GAAYnE,YACnCC,WAAAA,aAGqByC,EAAWD,EAAgB,CAChDQ,OAAQ,OACRC,KAAMkB,2BAFAC,IAAAA,KAKFC,gBACQ1B,GAAeV,EAAiBjC,WACnC0C,EAAUwB,GAAYrE,eAGrB,UACPT,EAAcsD,EAAUwB,GAAYnE,uBAIfuE,EAAOD,MAAMD,EAAMC,EAAO,CAAEE,WAAW,cAA3DC,SAEkC,IAApCnE,OAAOC,KAAKkE,GAAa1I,iDAEpB,CAAEU,KAAM,GAAIiI,MAAO,mBAGtBC,EAAaF,EAAY,UAAUjK,KAAI,SAAAoK,UACzCA,EAAKlK,GAAKkK,EAAKlK,IAAMkK,EAAK,OACnBA,KAGL7E,EAAO8E,OACTF,EAAaA,EAAWE,MAAK,SAACC,EAAGC,UAC3BD,EAAE/E,EAAO8E,KAAKG,SAAUD,EAAEhF,EAAO8E,KAAKG,SACd,QAAtBjF,EAAO8E,KAAKI,MACPH,EAAE/E,EAAO8E,KAAKG,OAAOE,cAAcH,EAAEhF,EAAO8E,KAAKG,QAEjDD,EAAEhF,EAAO8E,KAAKG,OAAOE,cAAcJ,EAAE/E,EAAO8E,KAAKG,aAO5DjF,EAAOoF,aACTR,EAAaA,EAAWxF,OACrBY,EAAOoF,WAAWC,KAAO,GAAKrF,EAAOoF,WAAWE,QACjDtF,EAAOoF,WAAWC,KAAOrF,EAAOoF,WAAWE,4BAIxC,CAAE5I,KAAMkI,EAAYD,MAAOD,EAAY,UAAU1I,mHAIrD,CACLuJ,sCAAS,WAAOnB,EAAYpE,wGACrB4C,EAAUwB,KAEXpE,EAAOrF,IAAMqF,EAAO,QAAU4C,EAAUwB,GAAYoB,wCAChDzD,EAAM/B,EAAOrF,IAAMqF,EAAO,QAAU4C,EAAUwB,GAAYqB,sBAC3C9C,EAAWZ,sBAA1BuC,IAAAA,KA1HE1H,EA4HG,gBA3HX8I,OAAAA,EAAAA,GADc7I,EA4HcyH,GA3HJ1H,MAAQC,EAAS,WACxCtC,MAAMC,QAAQkL,GAAgBA,EAAa5J,SAASc,GAAQ8I,IAAiB9I,2BA8HxEgI,EAAaN,EAAK,gBAAgB7J,KAAI,SAAAoK,UACxCA,EAAKlK,GAAKkK,EAAKlK,IAAMkK,EAAK,OACnBA,KAIL7E,EAAO5E,SAEL4E,EAAO5E,OAAOiF,UACTL,EAAO5E,OAAOiF,EAEnBE,OAAOC,KAAKR,EAAO5E,QAAQY,OAAS,IACtC4I,EAAaA,EAAWxJ,QAAO,SAAAyB,UAC7B0D,OAAOY,QAAQnB,EAAO5E,QAAQuK,MAAK,yBAAEC,OAAGlI,cACtCnD,MAAMC,QAAQqC,EAAS+I,IAAM/I,EAAS+I,GAAG9J,SAAS4B,GAAKb,EAAS+I,KAAOlI,UAM3EsC,EAAO8E,OACTF,EAAaA,EAAWE,MAAK,SAACC,EAAGC,UAC3BD,EAAE/E,EAAO8E,KAAKG,SAAUD,EAAEhF,EAAO8E,KAAKG,SACd,QAAtBjF,EAAO8E,KAAKI,MACPH,EAAE/E,EAAO8E,KAAKG,OAAOE,cAAcH,EAAEhF,EAAO8E,KAAKG,QAEjDD,EAAEhF,EAAO8E,KAAKG,OAAOE,cAAcJ,EAAE/E,EAAO8E,KAAKG,aAO5DjF,EAAOoF,aACTR,EAAaA,EAAWxF,OACrBY,EAAOoF,WAAWC,KAAO,GAAKrF,EAAOoF,WAAWE,QACjDtF,EAAOoF,WAAWC,KAAOrF,EAAOoF,WAAWE,4BAIxC,CAAE5I,KAAMkI,EAAYD,MAAOL,EAAK,gBAAgBtI,qBAOnDsI,EAAKuB,wCACclD,EAAW2B,EAAKuB,eAA/BC,SACNxB,EAAOwB,EAAOxB,gBAGVyB,EAAe,CAAC,kBAAmB,eAAgB,WAAY,SAASC,MAAK,SAAAC,UAAK3B,EAAK2B,gDACnE,CAAEvJ,KAAM,GAAIiI,MAAO,mBAIzCC,EAAaN,EAAKyB,GAActL,KAAI,SAAAoK,UACtCA,EAAKlK,GAAKkK,EAAKlK,IAAMkK,EAAK,OACnBA,uBAGF,CAAEnI,KAAMkI,EAAYD,MAAOL,EAAK4B,8DAG5B/B,EAAcC,EAAYpE,8EAjMhC,IAACpD,EAAMC,EACd6I,0DAkOJS,qCAAQ,WAAO/B,EAAYpE,4GACpB4C,EAAUwB,GAGTgC,EAAYxD,EAAUwB,YAEPzB,EAAW3C,EAAOrF,4BAAjC2J,IAAAA,MACD3J,GAAK2J,EAAK3J,IAAM2J,EAAK,gBAEAE,EAAO6B,QAAQ/B,EAAMzB,GAAeV,EAAiBjC,cAAzEwE,SAEF0B,EAAUE,WAAY,KACKF,EAAUE,2CAA5BC,UACL7B,EAAY6B,KAAoBhM,MAAMC,QAAQkK,EAAY6B,MAC5D7B,EAAY6B,GAAkB,CAAC7B,EAAY6B,6DAI1C,CAAE7J,KAAMgI,+FAEjB8B,sCAAS,WAAOpC,EAAYpE,mGACtB4E,EAAa,OAEF5E,EAAOyG,qEACpB9L,EAAmB,WAAdK,EADEL,WACuBA,EAAG,OAASA,qBAGnBgI,EAAWhI,qBAA1B2J,IAAAA,MACD3J,GAAKA,EACViK,EAAWrD,KAAK+C,qDAKZvB,GAEF6B,EAAWrD,KAAK,CAAE5G,GAAAA,4KAOjB,CAAE+B,KAAMkI,0HAEjB8B,+CAAkB,WAAOtC,EAAYpE,0FACnCA,EAAO5E,cAAc4E,EAAO5E,gBAAS4E,EAAO2G,OAAS3G,EAAOrF,cAC/CwJ,EAAcC,EAAYpE,qIAEzC4G,qCAAQ,WAAOxC,EAAYpE,kHACpB4C,EAAUwB,KAE4BxB,EAAUwB,GAA7CyC,IAAAA,UAAWpB,IAAAA,aAAc1F,IAAAA,MAC3BqD,EAAU,IAAIC,QAEhBwD,GACFzD,EAAQ0D,IACN,OACAvM,MAAMC,QAAQqM,GAAaA,EAAUpM,KAAI,SAAAsM,UAAK/G,EAAOtD,KAAKqK,MAAI1H,KAAK,KAAOW,EAAOtD,KAAKmK,aAKtE7C,EAAehE,EAAOtD,oBAA1CsD,EAAOtD,qBAEoCiG,EAAW8C,EAAc,CAClEvC,OAAQ,OACRE,QAAAA,EACAD,KAAM6D,KAAKC,wBACGpE,GAAeV,EAAiBjC,WACnCH,GACNC,EAAOtD,gCANGwK,IAAT9D,QAWF+D,EAAcD,EAAgBnD,IAAI,sBACnBpB,EAAWwE,4BAA1B7C,IAAAA,MACD3J,GAAK2J,EAAK3J,IAAM2J,EAAK,yBACnB,CAAE5H,KAAM4H,+FAEjB8C,qCAAQ,WAAOhD,EAAYpE,mGAELgE,EAAehE,EAAOtD,oBAA1CsD,EAAOtD,qBACDiG,EAAW3C,EAAOrF,GAAI,CAC1BuI,OAAQ,MACRC,KAAM6D,KAAKC,wBACGpE,GAAeV,EAAiBjC,IACzCF,EAAOtD,yCAIP,CAAEA,KAAMsD,EAAOtD,iGAExB2K,WAAY,SAACjD,EAAYpE,SACjB,IAAIiD,MAAM,2EAEV,WAAOmB,EAAYpE,mGACnB2C,EAAW3C,EAAOrF,GAAI,CAC1BuI,OAAQ,2CAEH,CAAExG,KAAM,CAAE/B,GAAIqF,EAAOrF,gGAE9B2M,yCAAY,WAAOlD,EAAYpE,+FACzByG,EAAM,OACKzG,EAAOyG,qEAAb9L,4BAECgI,EAAWhI,EAAI,CACnBuI,OAAQ,kBAEVuD,EAAIlF,KAAK5G,6NAGN,CAAE+B,KAAM+J,4HCzWf9D,EAAa,SAACZ,OAAKwF,yDAAU,UAC5BA,EAAQnE,UAASmE,EAAQnE,QAAU,IAAIC,SAEpCkE,EAAQrE,YACT,WACA,YACA,MACEqE,EAAQnE,QAAQoE,IAAI,WAAWD,EAAQnE,QAAQ0D,IAAI,SAAU,uBAC7DS,EAAQnE,QAAQoE,IAAI,iBAAiBD,EAAQnE,QAAQ0D,IAAI,eAAgB,iCAG3E,mBAGA,cAEES,EAAQnE,QAAQoE,IAAI,WAAWD,EAAQnE,QAAQ0D,IAAI,SAAU,2BAIhEW,EAAQC,aAAaC,QAAQ,gBAC/BF,GAAOF,EAAQnE,QAAQ0D,IAAI,iCAA2BW,IAEnDG,EAAWC,UAAU9F,EAAKwF"}