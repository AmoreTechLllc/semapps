{"version":3,"file":"index.es.js","sources":["../src/fields/ImageField.js","../src/fields/ReferenceArrayField.js","../src/fields/ReferenceField.js","../src/dataHandling/FilterHandler.js","../src/dataHandling/GroupedReferenceHandler.js","../src/inputs/DateTimeInput.js","../src/inputs/ReferenceArrayInput.js","../src/inputs/ReferenceInput.js","../src/inputs/ReificationArrayInput.js","../src/hooks/useCreateContainer.js","../src/dataProvider/utils/getServerKeyFromType.js","../src/dataProvider/utils/getServerKeyFromUri.js","../src/dataProvider/utils/fetchResource.js","../src/dataProvider/methods/getOne.js","../src/dataProvider/utils/uploadAllFiles.js","../src/dataProvider/utils/findContainersWithTypes.js","../src/dataProvider/methods/create.js","../src/dataProvider/methods/delete.js","../src/dataProvider/methods/deleteMany.js","../src/dataProvider/methods/getCreateContainer.js","../src/dataProvider/utils/fetchContainers.js","../src/dataProvider/utils/getEmbedFrame.js","../src/dataProvider/utils/buildDereferenceQuery.js","../src/dataProvider/utils/buildSparqlQuery.js","../src/dataProvider/utils/getRdfPrefixes.js","../src/dataProvider/utils/fetchSparqlEndpoints.js","../src/dataProvider/methods/getList.js","../src/dataProvider/methods/getMany.js","../src/dataProvider/methods/getManyReference.js","../src/dataProvider/methods/update.js","../src/dataProvider/utils/fetchUserConfig.js","../src/dataProvider/utils/fetchVoidEndpoints.js","../src/dataProvider/dataProvider.js","../src/httpClient.js"],"sourcesContent":["import React from 'react';\nimport { ImageField as RaImageField } from 'react-admin';\n\nconst ImageField = ({ record, source, ...otherProps }) => {\n  // For the display, we need to have the URI in a src property\n  if (typeof record === 'string') record = { [source]: record };\n  return <RaImageField record={record} source={source} {...otherProps} />;\n};\n\nexport default ImageField;\n","import React from 'react';\nimport { ReferenceArrayField as RaReferenceArrayField } from 'react-admin';\n\nconst ReferenceArrayField = ({ record, source, ...otherProps }) => {\n  if (record?.[source]) {\n    if (!Array.isArray(record[source])) {\n      record[source] = [record[source]];\n    }\n    record[source] = record[source].map(i => i['@id'] || i.id || i);\n  }\n  return <RaReferenceArrayField record={record} source={source} {...otherProps} />;\n};\n\nReferenceArrayField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceArrayField;\n","import React from 'react';\nimport { ReferenceField as RaReferenceField } from 'react-admin';\n\nconst ReferenceField = ({ record, source, ...otherProps }) => {\n  if (record[source]) {\n    if (typeof record[source] === 'object') {\n      record[source] = record[source]['@id'] || record[source].id;\n    }\n  }\n  return <RaReferenceField record={record} source={source} {...otherProps} />;\n};\n\nReferenceField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceField;\n","import React, { useState, useEffect } from 'react';\n\n/**\n * @example\n * <Show>\n *   <FilterHandler\n *     source=\"property\" // ex pair:organizationOfMembership\n *     filter={{\n *       'propertyToFilter':'value'\n *     }} // ex {{'pair:membershipRole':'http://localhost:3000/membership-roles/role-1'}}\n *     >\n *     <SingleFieldList>\n *    </SingleFieldList>\n *   </FilterHandler>\n * </Show>\n */\n\nconst FilterHandler = ({ children, record, filter, source, ...otherProps }) => {\n  const [filtered, setFiltered] = useState();\n  useEffect(() => {\n    if (record && source && Array.isArray(record?.[source])) {\n      const filteredData = record?.[source].filter(r => {\n        let eq = true;\n        for (const key in filter) {\n          const value = r[key];\n          if (Array.isArray(value)) {\n            if (!value.includes(filter[key])) {\n              eq = false;\n            }\n          } else {\n            if (value !== filter[key]) {\n              eq = false;\n            }\n          }\n        }\n        return eq;\n      });\n      let newRecord = {\n        ...record\n      };\n      //undefined setted if no data to obtain no render in RightLabel or equivalent\n      newRecord[source] = filteredData.length > 0 ? filteredData : undefined;\n      setFiltered(newRecord);\n    }\n  }, [record, source, filter]);\n\n  return (\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          ...otherProps,\n          record: filtered,\n          addLabel: true,\n          source\n        });\n      })}\n    </>\n  );\n};\nexport default FilterHandler;\n","import React from 'react';\nimport { useQueryWithStore } from 'react-admin';\nimport { default as FilterHandler } from './FilterHandler';\n\n/*\n * @example Label used in examples\n *  const Label = ({label, ...otherProps})=>{\n *     return <h2>{label}</h2>\n *  }\n *\n * @example show header for each group with group property thanks to groupHeader\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupHeader={({group,...otherProps}) => <Label {...otherProps} label={group['pair:label']}></Label> }\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example call chhildren with label thanks to groupLabel\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example conditional show of group if no data in source. Conditionale groupHeader is not possible because GroupedArrayField define group before filter ; need use chhildren.\n * const ConditionalSourceDefinedHandler = ({record,source,children,...otherProps})=>{\n *   if (record?.[source] && (!Array.isArray(record[source])||record[source].length>0)){\n *     return  React.Children.map(children, (child, i) => {\n *         return React.cloneElement(child, {...otherProps,record,source});\n *       })\n *   }else{\n *     return <></>\n *   }\n * }\n *\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *  <ConditionalSourceDefinedHandler>\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n *  </ConditionalSourceDefinedHandler>\n * </GroupedReferenceHandler>\n *\n *\n */\nconst GroupedReferenceHandler = ({\n  children,\n  groupReference,\n  groupLabel,\n  groupHeader,\n  filterProperty,\n  ...otherProps\n}) => {\n  const { data } = useQueryWithStore({\n    type: 'getList',\n    resource: groupReference,\n    payload: {}\n  });\n\n  return (\n    <>\n      {data?.map((data, index) => {\n        let filter = {};\n        filter[filterProperty] = data.id;\n        return (\n          <>\n            {groupHeader && groupHeader({ ...otherProps, group: data })}\n            <FilterHandler {...otherProps} filter={filter} label={data[groupLabel]}>\n              {children}\n            </FilterHandler>\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport default GroupedReferenceHandler;\n","import React from 'react';\nimport { DateTimeInput as RaDateTimeInput } from 'react-admin';\n\n/**\n * @deprecated Use the component from the @semapps/date-components instead\n */\nconst DateTimeInput = props => (\n  <RaDateTimeInput {...props} format={value => value && value.replace(' ', 'T').replace('Z', '')} />\n);\n\nexport default DateTimeInput;\n","import React from 'react';\nimport { ReferenceArrayInput as RaReferenceArrayInput, useResourceContext } from 'react-admin';\n\nconst ReferenceArrayInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceArrayInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // if the linked field value is not an array, turns it into an array.\n        // Necessary as JSON-LD are sometimes arrays, sometimes not (when there is one value)\n        // and the ReferenceArrayInput component only accept arrays\n        if (!Array.isArray(value)) value = [value];\n        // If a format prop was defined, apply it to the array\n        if (props.format) value = props.format(value);\n        // If the values are objects with @id field, turn it to a simple string\n        return value.map(v => (typeof v === 'object' ? v.id || v['@id'] : v));\n      }}\n    />\n  );\n};\n\nexport default ReferenceArrayInput;\n","import React from 'react';\nimport { ReferenceInput as RaReferenceInput, useResourceContext } from 'react-admin';\n\nconst ReferenceInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // If a format prop was defined, apply it\n        if (props.format) value = props.format(value);\n        // If the value is an object with an @id field, return the uri\n        return typeof value === 'object' ? value.id || value['@id'] : value;\n      }}\n    />\n  );\n};\n\nexport default ReferenceInput;\n","import React, { useEffect, useState } from 'react';\nimport { ArrayInput, SimpleFormIterator, TextInput } from 'react-admin';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useReferenceInputStyles = makeStyles({\n  form: {\n    display: 'flex'\n  },\n  input: {\n    paddingRight: '20px'\n  }\n});\n\nconst useHideInputStyles = makeStyles({\n  root: {\n    display: 'none'\n  }\n});\n\nconst ReificationArrayInput = props => {\n  const { reificationClass, children, ...otherProps } = props;\n  const flexFormClasses = useReferenceInputStyles();\n  const hideInputStyles = useHideInputStyles();\n\n  return (\n    <ArrayInput {...otherProps}>\n      <SimpleFormIterator classes={{ form: flexFormClasses.form }}>\n        {React.Children.map(props.children, (child, i) => {\n          return React.cloneElement(child, {\n            className: flexFormClasses.input\n          });\n        })}\n        <TextInput className={hideInputStyles.root} source=\"type\" initialValue={reificationClass} />\n      </SimpleFormIterator>\n    </ArrayInput>\n  );\n};\n\nexport default ReificationArrayInput;\n","import { useContext, useState, useEffect } from 'react';\nimport { DataProviderContext } from 'react-admin';\n\nconst useCreateContainer = resourceId => {\n  // Get the raw data provider, since useDataProvider returns a wrapper\n  const dataProvider = useContext(DataProviderContext);\n  const [createContainer, setCreateContainer] = useState();\n\n  useEffect(() => {\n    if (resourceId) {\n      dataProvider.getCreateContainer(resourceId).then(containerUri => setCreateContainer(containerUri));\n    }\n  }, [resourceId]);\n\n  return createContainer;\n};\n\nexport default useCreateContainer;\n","const getServerKeyFromType = (type, dataServers) => {\n  return Object.keys(dataServers).find(key => {\n    return dataServers[key][type];\n  });\n};\n\nexport default getServerKeyFromType;\n","// Return the first server matching with the baseUrl\nconst getServerKeyFromUri = (uri, dataServers) => {\n  return Object.keys(dataServers).find(key => {\n    return uri.startsWith(dataServers[key].baseUrl);\n  });\n};\n\nexport default getServerKeyFromUri;\n","import getServerKeyFromType from './getServerKeyFromType';\nimport getServerKeyFromUri from './getServerKeyFromUri';\nimport jsonld from 'jsonld';\n\nconst fetchResource = async (resourceUri, config) => {\n  const { dataServers, httpClient, jsonContext } = config;\n\n  const authServerKey = getServerKeyFromType('authServer', dataServers);\n  const serverKey = getServerKeyFromUri(resourceUri, dataServers);\n\n  // Fetch through proxy server if it is available\n  let { json: data } =\n    serverKey !== authServerKey && dataServers[authServerKey]?.proxyUrl && dataServers[serverKey]?.noProxy !== true\n      ? await httpClient(dataServers[authServerKey].proxyUrl, {\n          method: 'POST',\n          headers: new Headers({ 'Content-Type': 'application/x-www-form-urlencoded' }),\n          body: new URLSearchParams({ id: resourceUri })\n        })\n      : await httpClient(resourceUri, {\n          noToken: serverKey !== authServerKey\n        });\n\n  data.id = data.id || data['@id'];\n\n  // We compact only if the context is different between the frontend and the middleware\n  // TODO deep compare if the context is an object\n  if (data['@context'] !== jsonContext) {\n    data = await jsonld.compact(data, jsonContext);\n  }\n\n  return data;\n};\n\nexport default fetchResource;\n","import fetchResource from '../utils/fetchResource';\n\nconst getOneMethod = config => async (resourceId, params) => {\n  const { resources } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const data = await fetchResource(params.id, config);\n\n  // Transform single value into array if forceArray is set\n  if (dataModel.list?.forceArray) {\n    for (const forceArrayItem of dataModel.list?.forceArray) {\n      if (data[forceArrayItem] && !Array.isArray(data[forceArrayItem])) {\n        data[forceArrayItem] = [data[forceArrayItem]];\n      }\n    }\n  }\n\n  if (dataModel.list?.dereference) {\n    for (const dereferenceItem of dataModel.list?.dereference) {\n      if (\n        data[dereferenceItem] &&\n        typeof data[dereferenceItem] === 'string' &&\n        data[dereferenceItem].startsWith('http')\n      ) {\n        try {\n          const dataToEmbed = await fetchResource(data[dereferenceItem], config);\n          delete dataToEmbed['@context'];\n          data[dereferenceItem] = dataToEmbed;\n        } catch (e) {\n          // Ignore errors (this may happen if user does not have rights to see the resource)\n        }\n      }\n    }\n  }\n\n  return { data: data };\n};\n\nexport default getOneMethod;\n","import createSlug from 'speakingurl';\nimport urlJoin from 'url-join';\n\nexport const getSlugWithExtension = fileName => {\n  let fileExtension = '';\n  let splitFileName = fileName.split('.');\n  if (splitFileName.length > 1) {\n    fileExtension = splitFileName.pop();\n    fileName = splitFileName.join('.');\n  }\n  return createSlug(fileName, { lang: 'fr' }) + '.' + fileExtension;\n};\n\nexport const isFile = o => o && o.rawFile && o.rawFile instanceof File;\n\nconst getUploadsContainerUri = config => {\n  const serverKey = Object.keys(config.dataServers).find(key => config.dataServers[key].uploadsContainer);\n  if (serverKey) {\n    return urlJoin(config.dataServers[serverKey].baseUrl, config.dataServers[serverKey].uploadsContainer);\n  }\n};\n\nconst uploadFile = async (rawFile, config) => {\n  const uploadsContainerUri = getUploadsContainerUri(config);\n  if (!uploadsContainerUri) throw new Error(\"You must define an uploadsContainer in one of the server's configuration\");\n\n  const response = await config.httpClient(uploadsContainerUri, {\n    method: 'POST',\n    body: rawFile,\n    headers: new Headers({\n      // We must sluggify the file name, because we can't use non-ASCII characters in the header\n      // However we keep the extension apart (if it exists) so that it is not replaced with a -\n      // TODO let the middleware guess the extension based on the content type\n      Slug: getSlugWithExtension(rawFile.name),\n      'Content-Type': rawFile.type\n    })\n  });\n\n  if (response.status === 201) {\n    return response.headers.get('Location');\n  }\n};\n\n/*\n * Look for raw files in the record data.\n * If there are any, upload them and replace the file by its URL.\n */\nconst uploadAllFiles = async (record, config) => {\n  for (let property in record) {\n    if (record.hasOwnProperty(property)) {\n      if (Array.isArray(record[property])) {\n        for (let i = 0; i < record[property].length; i++) {\n          if (isFile(record[property][i])) {\n            record[property][i] = await uploadFile(record[property][i].rawFile, config);\n          }\n        }\n      } else {\n        if (isFile(record[property])) {\n          record[property] = await uploadFile(record[property].rawFile, config);\n        }\n      }\n    }\n  }\n  return record;\n};\n\nexport default uploadAllFiles;\n","import urlJoin from 'url-join';\n\nconst findContainersWithTypes = (types, servers, dataServers) => {\n  let containers = {};\n  let existingContainers = [];\n  Object.keys(dataServers).forEach(key1 => {\n    Object.keys(dataServers[key1].containers).forEach(key2 => {\n      if (!servers || (Array.isArray(servers) ? servers.includes(key2) : servers === key2)) {\n        Object.keys(dataServers[key1].containers[key2]).forEach(type => {\n          if (types.includes(type)) {\n            dataServers[key1].containers[key2][type].map(path => {\n              const containerUri = urlJoin(dataServers[key2].baseUrl, path);\n\n              // Avoid returning the same container several times\n              if (!existingContainers.includes(containerUri)) {\n                existingContainers.push(containerUri);\n\n                if (!containers[key1]) containers[key1] = [];\n                containers[key1].push(containerUri);\n              }\n            });\n          }\n        });\n      }\n    });\n  });\n  return containers;\n};\n\nexport default findContainersWithTypes;\n","import getOne from './getOne';\nimport uploadAllFiles from '../utils/uploadAllFiles';\nimport findContainersWithTypes from '../utils/findContainersWithTypes';\nimport getServerKeyFromUri from '../utils/getServerKeyFromUri';\n\nconst createMethod = config => async (resourceId, params) => {\n  const { dataServers, resources, httpClient, jsonContext } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const headers = new Headers();\n\n  if (dataModel.fieldsMapping?.title) {\n    headers.set('Slug', params.data[dataModel.fieldsMapping?.title]);\n  }\n\n  let containerUri, serverKey;\n  if (dataModel.create?.container) {\n    containerUri = dataModel.create?.container;\n    serverKey = getServerKeyFromUri(containerUri, dataServers);\n  } else {\n    serverKey =\n      dataModel.create?.server || Object.keys(config.dataServers).find(key => config.dataServers[key].default === true);\n    if (!serverKey) throw new Error('You must define a server for the creation, or a container, or a default server');\n\n    const containers = findContainersWithTypes(dataModel.types, [serverKey], dataServers);\n    // Extract the containerUri from the results (and ensure there is only one)\n    const serverKeys = Object.keys(containers);\n\n    if (!serverKeys || serverKeys.length === 0)\n      throw new Error(`No container with types ${JSON.stringify(dataModel.types)} found on server ${serverKey}`);\n    if (serverKeys.length > 1 || containers[serverKeys[0]].length > 1)\n      throw new Error(\n        `More than one container detected with types ${JSON.stringify(dataModel.types)} on server ${serverKey}`\n      );\n    containerUri = containers[serverKeys[0]][0];\n  }\n\n  // Upload files, if there are any\n  params.data = await uploadAllFiles(params.data, config);\n\n  const { headers: responseHeaders } = await httpClient(containerUri, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n      '@context': jsonContext,\n      '@type': dataModel.types,\n      ...params.data\n    }),\n    noToken: dataServers[serverKey].authServer !== true\n  });\n\n  // Retrieve newly-created resource\n  const resourceUri = responseHeaders.get('Location');\n  return await getOne(config)(resourceId, { id: resourceUri });\n};\n\nexport default createMethod;\n","import getServerKeyFromUri from '../utils/getServerKeyFromUri';\n\nconst deleteMethod = config => async (resourceId, params) => {\n  const { dataServers, httpClient } = config;\n  const serverKey = getServerKeyFromUri(params.id, dataServers);\n\n  await httpClient(params.id, {\n    method: 'DELETE',\n    noToken: !serverKey || dataServers[serverKey].authServer !== true\n  });\n\n  return { data: { id: params.id } };\n};\n\nexport default deleteMethod;\n","const deleteManyMethod = config => async (resourceId, params) => {\n  const { httpClient } = config;\n  let ids = [];\n\n  for (let id of params.ids) {\n    try {\n      await httpClient(id, {\n        method: 'DELETE'\n      });\n      ids.push(id);\n    } catch (e) {\n      // Do nothing if we fail to delete a resource\n    }\n  }\n\n  return { data: ids };\n};\n\nexport default deleteManyMethod;\n","import urlJoin from 'url-join';\nimport getServerKeyFromType from '../utils/getServerKeyFromType';\n\nconst findCreateContainerWithTypes = (types, createServerKey, dataServers) => {\n  let containers = [];\n  Object.keys(dataServers[createServerKey].containers[createServerKey]).forEach(type => {\n    if (types.includes(type)) {\n      dataServers[createServerKey].containers[createServerKey][type].map(path => {\n        const containerUri = urlJoin(dataServers[createServerKey].baseUrl, path);\n        if (!containers.includes(containerUri)) {\n          containers.push(containerUri);\n        }\n      });\n    }\n  });\n\n  if (containers.length === 0) {\n    throw new Error(\n      `No container found matching with types ${JSON.stringify(\n        types\n      )}. You can set explicitely the create.container property of the resource.`\n    );\n  } else if (containers.length > 1) {\n    throw new Error(\n      `More than one container found matching with types ${JSON.stringify(\n        types\n      )}. You must set the create.server or create.container property for the resource.`\n    );\n  }\n\n  return containers[0];\n};\n\nconst getCreateContainer = config => resourceId => {\n  let { dataServers, resources } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  if (dataModel.create?.container) {\n    return dataModel.create?.container;\n  } else if (dataModel.create?.server) {\n    return findCreateContainerWithTypes(dataModel.types, dataModel.create?.server, dataServers);\n  } else {\n    const defaultServerKey = getServerKeyFromType('default', dataServers);\n    return findCreateContainerWithTypes(dataModel.types, defaultServerKey, dataServers);\n  }\n};\n\nexport default getCreateContainer;\n","import jsonld from 'jsonld';\n\nexport const isType = (type, resource) => {\n  const resourceType = resource.type || resource['@type'];\n  return Array.isArray(resourceType) ? resourceType.includes(type) : resourceType === type;\n};\n\nconst fetchContainers = async (containers, resourceId, params, config) => {\n  const { dataServers, httpClient, jsonContext } = config;\n\n  // Transform in an containerUri:serverKey object\n  const containersServers = Object.keys(containers).reduce(\n    (acc, serverKey) => ({\n      ...acc,\n      ...Object.fromEntries(containers[serverKey].map(containerUri => [containerUri, serverKey]))\n    }),\n    {}\n  );\n\n  const fetchPromises = Object.keys(containersServers).map(containerUri =>\n    httpClient(containerUri, {\n      noToken: !containersServers[containerUri] || dataServers[containersServers[containerUri]].authServer !== true\n    })\n      .then(({ json }) => {\n        // If container's context is different, compact it to have an uniform result\n        // TODO deep compare if the context is an object\n        if (json['@context'] !== jsonContext) {\n          return jsonld.compact(json, jsonContext);\n        } else {\n          return json;\n        }\n      })\n      .then(json => {\n        if (isType('ldp:Container', json)) {\n          return json['ldp:contains'];\n        } else {\n          throw new Error(containerUri + ' is not a LDP container');\n        }\n      })\n  );\n\n  // Fetch simultaneously all containers\n  let results = await Promise.all(fetchPromises);\n\n  if (results.length === 0) {\n    return { data: [], total: 0 };\n  } else {\n    // Merge all results in one array\n    results = [].concat.apply(...results);\n\n    let returnData = results.map(item => {\n      item.id = item.id || item['@id'];\n      return item;\n    });\n\n    // Apply filter to results\n    if (params.filter) {\n      // For SPARQL queries, we use \"a\" to filter types, but in containers it must be \"type\"\n      if (params.filter.a) {\n        params.filter.type = params.filter.a;\n        delete params.filter.a;\n      }\n\n      // Remove search params from filter\n      if (params.filter.q) {\n        delete params.filter.q;\n      }\n      if (Object.keys(params.filter).length > 0) {\n        returnData = returnData.filter(resource =>\n          Object.entries(params.filter).some(([k, v]) =>\n            Array.isArray(resource[k]) ? resource[k].includes(v) : resource[k] === v\n          )\n        );\n      }\n    }\n\n    if (params.sort) {\n      returnData = returnData.sort((a, b) => {\n        if (a[params.sort.field] && b[params.sort.field]) {\n          if (params.sort.order === 'ASC') {\n            return a[params.sort.field].localeCompare(b[params.sort.field]);\n          } else {\n            return b[params.sort.field].localeCompare(a[params.sort.field]);\n          }\n        } else {\n          return true;\n        }\n      });\n    }\n    if (params.pagination) {\n      returnData = returnData.slice(\n        (params.pagination.page - 1) * params.pagination.perPage,\n        params.pagination.page * params.pagination.perPage\n      );\n    }\n\n    return { data: returnData, total: results.length };\n  }\n};\n\nexport default fetchContainers;\n","const getEmbedFrame = paths => {\n  let embedFrame = {},\n    predicates;\n  if (paths) {\n    for (let path of paths) {\n      if (path.includes('/')) {\n        predicates = path.split('/').reverse();\n      } else {\n        predicates = [path];\n      }\n      embedFrame = {\n        ...embedFrame,\n        ...predicates.reduce(\n          (accumulator, predicate) => ({\n            [predicate]: {\n              '@embed': '@last',\n              ...accumulator\n            }\n          }),\n          {}\n        )\n      };\n    }\n    return embedFrame;\n  }\n};\n\nexport default getEmbedFrame;\n","import crypto from 'crypto';\n\n// Transform ['ont:predicate1/ont:predicate2'] to ['ont:predicate1', 'ont:predicate1/ont:predicate2']\nconst extractNodes = predicates => {\n  let nodes = [];\n  if (predicates) {\n    for (let predicate of predicates) {\n      if (predicate.includes('/')) {\n        const nodeNames = predicate.split('/');\n        for (let i = 1; i <= nodeNames.length; i++) {\n          nodes.push(nodeNames.slice(0, i).join('/'));\n        }\n      } else {\n        nodes.push(predicate);\n      }\n    }\n  }\n  return nodes;\n};\n\nconst generateSparqlVarName = node =>\n  crypto\n    .createHash('md5')\n    .update(node)\n    .digest('hex');\n\nconst getParentNode = node => node.includes('/') && node.split('/')[0];\n\nconst getPredicate = node => (node.includes('/') ? node.split('/')[1] : node);\n\nconst buildOptionalQuery = (queries, parentNode = false) =>\n  queries\n    .filter(q => q.parentNode === parentNode)\n    .map(\n      q => `\n      OPTIONAL { \n        ${q.query}\n        ${q.filter}\n        ${buildOptionalQuery(queries, q.node)}\n      }\n    `\n    )\n    .join('\\n');\n\nconst buildDereferenceQuery = predicates => {\n  let queries = [];\n  const nodes = extractNodes(predicates);\n\n  if (nodes) {\n    for (let node of nodes) {\n      const parentNode = getParentNode(node);\n      const predicate = getPredicate(node);\n      const varName = generateSparqlVarName(node);\n      const parentVarName = parentNode ? generateSparqlVarName(parentNode) : '1';\n\n      queries.push({\n        node,\n        parentNode,\n        query: `?s${parentVarName} ${predicate} ?s${varName} .\\n?s${varName} ?p${varName} ?o${varName} .`,\n        filter: '' // `FILTER(isBLANK(?s${varName})) .`\n      });\n    }\n\n    return {\n      construct: queries.map(q => q.query).join('\\n'),\n      where: buildOptionalQuery(queries)\n    };\n  } else {\n    return {\n      construct: '',\n      where: ''\n    };\n  }\n};\n\nexport default buildDereferenceQuery;\n","import buildDereferenceQuery from './buildDereferenceQuery';\nimport getRdfPrefixes from './getRdfPrefixes';\n\nconst buildSparqlQuery = ({ containers, params: { filter }, dereference, ontologies }) => {\n  let searchWhereQuery = '',\n    filterWhereQuery = '';\n\n  if (filter) {\n    if (filter.q && filter.q.length > 0) {\n      searchWhereQuery += `\n      {\n        SELECT ?s1\n        WHERE {\n          ?s1 ?p1 ?o1 .\n          FILTER regex(lcase(str(?o1)), \"${filter.q.toLowerCase()}\")\n          FILTER NOT EXISTS {?s1 a ?o1}\n        }\n      }\n      `;\n      delete filter.q;\n    }\n    Object.keys(filter).forEach(predicate => {\n      if (filter[predicate]) {\n        const object = filter[predicate].startsWith('http') ? `<${filter[predicate]}>` : filter[predicate];\n        filterWhereQuery += `?s1 ${predicate} ${object} .`;\n      }\n    });\n  }\n\n  const dereferenceQuery = buildDereferenceQuery(dereference);\n\n  return `\n    ${getRdfPrefixes(ontologies)}\n    CONSTRUCT {\n      ?s1 ?p2 ?o2 .\n      ${dereferenceQuery.construct}\n    }\n    WHERE {\n      ${filterWhereQuery}\n      ?containerUri ldp:contains ?s1 .\n      FILTER( ?containerUri IN (${containers.map(container => `<${container}>`).join(', ')}) ) .\n      FILTER( (isIRI(?s1)) ) .\n      ${searchWhereQuery}\n      ${dereferenceQuery.where}\n      ?s1 ?p2 ?o2 .\n    }\n  `;\n};\n\nexport default buildSparqlQuery;\n","const getRdfPrefixes = ontologies => {\n  return ontologies.map(ontology => `PREFIX ${ontology.prefix}: <${ontology.url}>`).join('\\n');\n};\n\nexport default getRdfPrefixes;\n","import getEmbedFrame from './getEmbedFrame';\nimport buildSparqlQuery from './buildSparqlQuery';\nimport jsonld from 'jsonld';\n\nconst fetchSparqlEndpoints = async (containers, resourceId, params, config) => {\n  const { dataServers, resources, httpClient, jsonContext, ontologies } = config;\n  const dataModel = resources[resourceId];\n\n  const frame = {\n    '@context': jsonContext,\n    '@type': dataModel.types,\n    // Embed only what we explicitly asked to dereference\n    // Otherwise we may have same-type resources embedded in other resources\n    '@embed': '@never',\n    ...getEmbedFrame(dataModel.list?.dereference)\n  };\n\n  const sparqlQueryPromises = Object.keys(containers).map(\n    serverKey =>\n      new Promise((resolve, reject) => {\n        const sparqlQuery = buildSparqlQuery({\n          containers: containers[serverKey],\n          params: { ...params, filter: { ...dataModel.list?.filter, ...params.filter } },\n          dereference: dataModel.list?.dereference,\n          ontologies\n        });\n\n        httpClient(dataServers[serverKey].sparqlEndpoint, {\n          method: 'POST',\n          body: sparqlQuery,\n          noToken: dataServers[serverKey].authServer !== true\n        })\n          .then(({ json }) => {\n            // omitGraph option force results to be in a @graph, even if we have a single result\n            return jsonld.frame(json, frame, { omitGraph: false });\n          })\n          .then(compactJson => {\n            resolve(compactJson['@graph'] || []);\n          })\n          .catch(e => reject(e));\n      })\n  );\n\n  // Run simultaneous SPARQL queries\n  let results = await Promise.all(sparqlQueryPromises);\n\n  if (results.length === 0) {\n    return { data: [], total: 0 };\n  } else {\n    // Merge all results in one array\n    results = [].concat.apply(...results);\n\n    // Add id in addition to @id, as this is what React-Admin expects\n    let returnData = results.map(item => {\n      item.id = item.id || item['@id'];\n      return item;\n    });\n\n    // TODO sort and paginate the results in the SPARQL query to improve performances\n    if (params.sort) {\n      returnData = returnData.sort((a, b) => {\n        if (a[params.sort.field] && b[params.sort.field]) {\n          if (params.sort.order === 'ASC') {\n            return a[params.sort.field].localeCompare(b[params.sort.field]);\n          } else {\n            return b[params.sort.field].localeCompare(a[params.sort.field]);\n          }\n        } else {\n          return true;\n        }\n      });\n    }\n    if (params.pagination) {\n      returnData = returnData.slice(\n        (params.pagination.page - 1) * params.pagination.perPage,\n        params.pagination.page * params.pagination.perPage\n      );\n    }\n\n    return { data: returnData, total: results.length };\n  }\n};\n\nexport default fetchSparqlEndpoints;\n","import findContainersWithTypes from '../utils/findContainersWithTypes';\nimport fetchContainers from '../utils/fetchContainers';\nimport fetchSparqlEndpoints from '../utils/fetchSparqlEndpoints';\n\nconst getListMethod = config => async (resourceId, params = {}) => {\n  let { dataServers, resources } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  let containers;\n  if (dataModel.list?.containers && dataModel.list?.containers.length > 0) {\n    // If containers are set explicitly, use them\n    containers = dataModel.list?.containers;\n  } else {\n    containers = findContainersWithTypes(dataModel.types, dataModel.list?.servers, dataServers);\n  }\n\n  if (dataModel.list?.fetchContainer) {\n    return fetchContainers(containers, resourceId, params, config);\n  } else {\n    return fetchSparqlEndpoints(containers, resourceId, params, config);\n  }\n};\n\nexport default getListMethod;\n","import getOne from './getOne';\n\nconst getManyMethod = config => async (resourceId, params) => {\n  const { returnFailedResources } = config;\n\n  let returnData = [];\n\n  for (let id of params.ids) {\n    id = typeof id === 'object' ? id['@id'] : id;\n\n    try {\n      const { data } = await getOne(config)(resourceId, { id });\n      returnData.push(data);\n    } catch (e) {\n      // Catch if one resource fails to load\n      // Otherwise no references will be show if only one is missing\n      // See https://github.com/marmelab/react-admin/issues/5190\n      if (returnFailedResources) {\n        // Return only the ID of the resource\n        returnData.push({ id });\n      } else {\n        // Do nothing. The resource will not appear in the results.\n      }\n    }\n  }\n\n  return { data: returnData };\n};\n\nexport default getManyMethod;\n","import getList from './getList';\n\nconst getManyReferenceMethod = config => async (resourceId, params) => {\n  params.filter = { ...params.filter, [params.target]: params.id };\n  delete params.target;\n  return await getList(config)(params);\n};\n\nexport default getManyReferenceMethod;\n","import uploadAllFiles from '../utils/uploadAllFiles';\nimport getServerKeyFromUri from '../utils/getServerKeyFromUri';\n\nconst updateMethod = config => async (resourceId, params) => {\n  const { dataServers, httpClient, jsonContext } = config;\n  const serverKey = getServerKeyFromUri(params.id, dataServers);\n\n  // Upload files, if there are any\n  params.data = await uploadAllFiles(params.data, config);\n\n  await httpClient(params.id, {\n    method: 'PUT',\n    body: JSON.stringify({\n      '@context': jsonContext,\n      ...params.data\n    }),\n    noToken: !serverKey || dataServers[serverKey].authServer !== true\n  });\n\n  return { data: params.data };\n};\n\nexport default updateMethod;\n","import jwtDecode from 'jwt-decode';\nimport getServerKeyFromType from './getServerKeyFromType';\nimport urlJoin from 'url-join';\n\nconst getContainerFromUri = str => str.match(new RegExp(`(.*)/.*`))[1];\n\nconst fetchUserConfig = async config => {\n  const { dataServers, httpClient } = config;\n  const token = localStorage.getItem('token');\n  const podKey = getServerKeyFromType('pod', dataServers);\n  const authServerKey = getServerKeyFromType('authServer', dataServers);\n\n  // If the user is logged in\n  if (token) {\n    const { webId } = jwtDecode(token);\n    const { json: userData } = await httpClient(webId);\n\n    // If we have a POD server\n    if (podKey) {\n      // Fill the config provided to the data provider\n      // We must modify the config object directly\n      config.dataServers[podKey].name = 'My Pod';\n      config.dataServers[podKey].baseUrl = urlJoin(webId, 'data'); // TODO find POD URI from user profile\n      config.dataServers[podKey].sparqlEndpoint =\n        userData.endpoints?.['void:sparqlEndpoint'] || urlJoin(webId, 'sparql');\n    }\n\n    if (authServerKey) {\n      // Fill the config provided to the data provider\n      // We must modify the config object directly\n      config.dataServers[authServerKey].proxyUrl = userData.endpoints?.proxyUrl;\n    }\n  } else {\n    if (podKey) {\n      // If the user is not logged in, ignore the POD server\n      delete config.dataServers[podKey];\n    }\n  }\n};\n\nexport default fetchUserConfig;\n","const fetchVoidEndpoints = async config => {\n  const fetchPromises = Object.values(config.dataServers)\n    .filter(server => server.pod !== true)\n    .map(server =>\n      config\n        .httpClient(new URL('/.well-known/void', server.baseUrl))\n        .then(result => ({ data: result.json }))\n        .catch(e => {\n          if (e.status === 404) {\n            return { error: e };\n          } else {\n            throw e;\n          }\n        })\n    );\n\n  try {\n    const results = await Promise.all(fetchPromises);\n\n    for (let result of results) {\n      // Ignore unfetchable endpoints\n      if (result.data) {\n        // TODO modify config.dataServers based on the VOID configs returned\n      }\n    }\n  } catch (e) {\n    // no block methods if no VOID\n  }\n};\n\nexport default fetchVoidEndpoints;\n","import createMethod from './methods/create';\nimport deleteMethod from './methods/delete';\nimport deleteManyMethod from './methods/deleteMany';\nimport getCreateContainerMethod from './methods/getCreateContainer';\nimport getListMethod from './methods/getList';\nimport getManyMethod from './methods/getMany';\nimport getManyReferenceMethod from './methods/getManyReference';\nimport getOneMethod from './methods/getOne';\nimport updateMethod from './methods/update';\nimport fetchUserConfig from './utils/fetchUserConfig';\nimport fetchVoidEndpoints from './utils/fetchVoidEndpoints';\nimport getServerKeyFromType from './utils/getServerKeyFromType';\n\nconst dataProvider = config => {\n  // TODO verify all data provider config + data models\n  if (!getServerKeyFromType('default', config.dataServers))\n    throw new Error('You must define a default server in your dataServers config');\n\n  if (!config.jsonContext) config.jsonContext = Object.fromEntries(config.ontologies.map(o => [o.prefix, o.url]));\n  if (!config.returnFailedResources) config.returnFailedResources = false;\n\n  const fetchUserConfigPromise = fetchUserConfig(config);\n  const fetchVoidEndpointsPromise = fetchVoidEndpoints(config);\n\n  const waitForVoidEndpoints = method => async (...arg) => {\n    await fetchUserConfigPromise;\n    await fetchVoidEndpointsPromise; // Return immediately if promise is fulfilled\n    return await method(...arg);\n  };\n\n  return {\n    getList: waitForVoidEndpoints(getListMethod(config)),\n    getOne: waitForVoidEndpoints(getOneMethod(config)),\n    getMany: waitForVoidEndpoints(getManyMethod(config)),\n    getManyReference: waitForVoidEndpoints(getManyReferenceMethod(config)),\n    create: waitForVoidEndpoints(createMethod(config)),\n    update: waitForVoidEndpoints(updateMethod(config)),\n    updateMany: () => {\n      throw new Error('updateMany is not implemented yet');\n    },\n    delete: waitForVoidEndpoints(deleteMethod(config)),\n    deleteMany: waitForVoidEndpoints(deleteManyMethod(config)),\n    getCreateContainer: waitForVoidEndpoints(getCreateContainerMethod(config))\n  };\n};\n\nexport default dataProvider;\n","import { fetchUtils } from 'react-admin';\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) options.headers = new Headers();\n\n  switch (options.method) {\n    case 'POST':\n    case 'PATCH':\n    case 'PUT':\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      if (!options.headers.has('Content-Type')) options.headers.set('Content-Type', 'application/ld+json');\n      break;\n\n    case 'DELETE':\n      break;\n\n    case 'GET':\n    default:\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      break;\n  }\n\n  if (!options.noToken) {\n    const token = localStorage.getItem('token');\n    if (token) options.headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return fetchUtils.fetchJson(url, options);\n};\n\nexport default httpClient;\n"],"names":["ImageField","record","source","otherProps","React","RaImageField","ReferenceArrayField","Array","isArray","map","i","id","RaReferenceArrayField","defaultProps","addLabel","ReferenceField","_typeof","RaReferenceField","FilterHandler","children","filter","useState","filtered","setFiltered","useEffect","filteredData","r","eq","key","value","includes","newRecord","length","undefined","Children","child","cloneElement","GroupedReferenceHandler","groupReference","groupLabel","groupHeader","filterProperty","data","useQueryWithStore","type","resource","payload","index","group","label","DateTimeInput","props","RaDateTimeInput","format","replace","ReferenceArrayInput","useResourceContext","RaReferenceArrayInput","v","ReferenceInput","RaReferenceInput","useReferenceInputStyles","makeStyles","form","display","input","paddingRight","useHideInputStyles","root","ReificationArrayInput","reificationClass","flexFormClasses","hideInputStyles","ArrayInput","SimpleFormIterator","classes","className","TextInput","initialValue","useCreateContainer","resourceId","dataProvider","useContext","DataProviderContext","createContainer","setCreateContainer","getCreateContainer","then","containerUri","getServerKeyFromType","dataServers","Object","keys","find","getServerKeyFromUri","uri","startsWith","baseUrl","fetchResource","resourceUri","config","httpClient","jsonContext","authServerKey","serverKey","_dataServers$authServ","proxyUrl","noProxy","method","headers","Headers","body","URLSearchParams","noToken","json","jsonld","compact","getOneMethod","params","resources","dataModel","Error","list","_dataModel$list","forceArray","_dataModel$list2","forceArrayItem","_dataModel$list3","dereference","_dataModel$list4","dereferenceItem","dataToEmbed","isFile","o","rawFile","File","getUploadsContainerUri","uploadsContainer","urlJoin","uploadFile","uploadsContainerUri","Slug","fileName","name","fileExtension","splitFileName","split","pop","join","createSlug","lang","response","status","get","uploadAllFiles","property","hasOwnProperty","findContainersWithTypes","types","servers","containers","existingContainers","forEach","key1","key2","path","push","createMethod","fieldsMapping","_dataModel$fieldsMapp","title","set","_dataModel$fieldsMapp2","create","_dataModel$create","container","_dataModel$create2","server","serverKeys","JSON","stringify","authServer","responseHeaders","getOne","deleteMethod","deleteManyMethod","ids","findCreateContainerWithTypes","createServerKey","_dataModel$create3","_dataModel$create4","defaultServerKey","fetchContainers","containersServers","reduce","acc","fromEntries","fetchPromises","resourceType","Promise","all","results","total","concat","apply","returnData","item","a","q","entries","some","k","sort","b","field","order","localeCompare","pagination","slice","page","perPage","getEmbedFrame","paths","predicates","embedFrame","reverse","accumulator","predicate","generateSparqlVarName","node","crypto","createHash","update","digest","getParentNode","getPredicate","buildOptionalQuery","queries","parentNode","query","buildDereferenceQuery","nodes","nodeNames","extractNodes","varName","parentVarName","construct","where","buildSparqlQuery","ontologies","searchWhereQuery","filterWhereQuery","toLowerCase","object","dereferenceQuery","ontology","prefix","url","getRdfPrefixes","fetchSparqlEndpoints","frame","sparqlQueryPromises","resolve","reject","sparqlQuery","sparqlEndpoint","omitGraph","compactJson","e","getListMethod","_dataModel$list5","fetchContainer","getManyMethod","returnFailedResources","getManyReferenceMethod","target","getList","updateMethod","fetchUserConfig","token","localStorage","getItem","podKey","jwtDecode","webId","userData","endpoints","_userData$endpoints2","fetchVoidEndpoints","values","pod","URL","result","error","fetchUserConfigPromise","fetchVoidEndpointsPromise","waitForVoidEndpoints","getMany","getManyReference","updateMany","deleteMany","getCreateContainerMethod","options","has","fetchUtils","fetchJson"],"mappings":"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"}