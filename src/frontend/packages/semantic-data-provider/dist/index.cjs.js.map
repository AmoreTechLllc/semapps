{"version":3,"file":"index.cjs.js","sources":["../src/fields/ReferenceArrayField.js","../src/fields/ReferenceField.js","../src/dataHandling/FilterHandler.js","../src/inputs/ReferenceArrayInput.js","../src/inputs/ReificationArrayInput.js","../src/buildSparqlQuery.js","../src/dataProvider.js","../src/inputs/DateTimeInput.js","../src/dataHandling/GroupedReferenceHandler.js","../src/fields/ImageField.js","../src/inputs/ReferenceInput.js","../src/httpClient.js"],"sourcesContent":["import React from 'react';\nimport { ReferenceArrayField as RaReferenceArrayField } from 'react-admin';\n\nconst ReferenceArrayField = ({ record, source, ...otherProps }) => {\n  if (record?.[source]) {\n    if (!Array.isArray(record[source])) {\n      record[source] = [record[source]];\n    }\n    record[source] = record[source].map(i => i['@id'] || i.id || i);\n  }\n  return <RaReferenceArrayField record={record} source={source} {...otherProps} />;\n};\n\nReferenceArrayField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceArrayField;\n","import React from 'react';\nimport { ReferenceField as RaReferenceField } from 'react-admin';\n\nconst ReferenceField = ({ record, source, ...otherProps }) => {\n  if (record[source]) {\n    if (typeof record[source] === 'object') {\n      record[source] = record[source]['@id'] || record[source].id;\n    }\n  }\n  return <RaReferenceField record={record} source={source} {...otherProps} />;\n};\n\nReferenceField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceField;\n","import React, { useState, useEffect } from 'react';\nimport { ArrayField } from 'react-admin';\n\n/**\n * @example\n * <Show>\n *   <FilterHandler\n *     source=\"property\" // ex pair:organizationOfMembership\n *     filter={{\n *       'propertyToFilter':'value'\n *     }} // ex {{'pair:membershipRole':'http://localhost:3000/membership-roles/role-1'}}\n *     >\n *     <SingleFieldList>\n *    </SingleFieldList>\n *   </FilterHandler>\n * </Show>\n */\n\nconst FilterHandler = ({ children, record, filter, source, ...otherProps }) => {\n  const [filtered, setFiltered] = useState();\n  useEffect(() => {\n    if (record && source && Array.isArray(record?.[source])) {\n      const filteredData = record?.[source].filter(r => {\n        let eq = true;\n        for (const key in filter) {\n          const value = r[key];\n          if (Array.isArray(value)) {\n            if (!value.includes(filter[key])) {\n              eq = false;\n            }\n          } else {\n            if (value !== filter[key]) {\n              eq = false;\n            }\n          }\n        }\n        return eq;\n      });\n      let newRecord = {\n        ...record\n      };\n      //undefined setted if no data to obtain no render in RightLabel or equivalent\n      newRecord[source] = filteredData.length > 0 ? filteredData : undefined;\n      setFiltered(newRecord);\n    }\n  }, [record, source, filter]);\n\n  return (\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          ...otherProps,\n          record: filtered,\n          addLabel: true,\n          source\n        });\n      })}\n    </>\n  );\n};\nexport default FilterHandler;\n","import React from 'react';\nimport { ReferenceArrayInput as RaReferenceArrayInput, useResourceContext } from 'react-admin';\n\nconst ReferenceArrayInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceArrayInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // if the linked field value is not an array, turns it into an array.\n        // Necessary as JSON-LD are sometimes arrays, sometimes not (when there is one value)\n        // and the ReferenceArrayInput component only accept arrays\n        if (!Array.isArray(value)) value = [value];\n        // If a format prop was defined, apply it to the array\n        if (props.format) value = props.format(value);\n        // If the values are objects with @id field, turn it to a simple string\n        return value.map(v => (typeof v === 'object' ? v.id || v['@id'] : v));\n      }}\n    />\n  );\n};\n\nexport default ReferenceArrayInput;\n","import React, { useEffect, useState } from 'react';\nimport { ArrayInput, SimpleFormIterator, TextInput } from 'react-admin';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useReferenceInputStyles = makeStyles({\n  form: {\n    display: 'flex'\n  },\n  input: {\n    paddingRight: '20px'\n  }\n});\n\nconst useHideInputStyles = makeStyles({\n  root: {\n    display: 'none'\n  }\n});\n\nconst ReificationArrayInput = props => {\n  const { reificationClass, children, ...otherProps } = props;\n  const flexFormClasses = useReferenceInputStyles();\n  const hideInputStyles = useHideInputStyles();\n\n  return (\n    <ArrayInput {...otherProps}>\n      <SimpleFormIterator classes={{ form: flexFormClasses.form }}>\n        {React.Children.map(props.children, (child, i) => {\n          return React.cloneElement(child, {\n            className: flexFormClasses.input\n          });\n        })}\n        <TextInput className={hideInputStyles.root} source=\"type\" initialValue={reificationClass} />\n      </SimpleFormIterator>\n    </ArrayInput>\n  );\n};\n\nexport default ReificationArrayInput;\n","const getPrefixRdf = ontologies => {\n  return ontologies.map(ontology => `PREFIX ${ontology.prefix}: <${ontology.url}>`).join('\\n');\n};\n\nconst buildSparqlQuery = ({ types, params: { sort, filter }, ontologies }) => {\n  let whereQuery = '', sortQuery = '';\n\n  if (filter) {\n    if (filter.q && filter.q.length > 0) {\n      whereQuery += `\n        ?resource ?p1 ?o1 .\n        FILTER isLITERAL(?o1) .\n        FILTER regex(lcase(str(?o1)), \"${filter.q.toLowerCase()}\") .\n      `;\n      delete filter.q;\n    }\n    Object.keys(filter).forEach(predicate => {\n      if (filter[predicate]) {\n        const object = filter[predicate].startsWith('http') ? `<${filter[predicate]}>` : filter[predicate];\n        whereQuery += `?resource ${predicate} ${object} .`;\n      }\n    });\n  }\n\n  return `\n    ${getPrefixRdf(ontologies)}\n    SELECT DISTINCT ?resource\n    WHERE {\n      ?resource a ?type .\n      FILTER( ?type IN (${types.join(', ')}) ) .\n      FILTER( (isIRI(?resource)) ) .\n      ${sort && sort.field.includes(':') ? `?resource ${sort.field} ?sortField .` : ''}\n      ${whereQuery}\n    }\n    ${sort && sort.field.includes(':') ? `ORDER BY ${sort.order}(?sortField)` : ''}\n  `;\n};\n\nexport default buildSparqlQuery;\n","import jsonld from 'jsonld';\nimport buildSparqlQuery from './buildSparqlQuery';\nconst createSlug = require('speakingurl');\n\nconst buildJsonContext = ontologies => {\n  let pattern = {};\n  ontologies.forEach(ontology => (pattern[ontology.prefix] = ontology.url));\n  return pattern;\n};\n\nconst isFile = o => o && o.rawFile && o.rawFile instanceof File;\n\nconst getSlugWithExtension = fileName => {\n  let fileExtension = '';\n  let splitFileName = fileName.split('.');\n  if (splitFileName.length > 1) {\n    fileExtension = splitFileName.pop();\n    fileName = splitFileName.join('.');\n  }\n  return createSlug(fileName, { lang: 'fr' }) + '.' + fileExtension;\n};\n\nconst isType = (type, resource) => {\n  const resourceType = resource.type || resource['@type'];\n  return Array.isArray(resourceType) ? resourceType.includes(type) : resourceType === type;\n};\n\nconst dataProvider = ({ sparqlEndpoint, httpClient, resources, ontologies, jsonContext, uploadsContainerUri }) => {\n  const uploadFile = async rawFile => {\n    if (!uploadsContainerUri) throw new Error('No uploadsContainerUri defined for the data provider');\n\n    const response = await httpClient(uploadsContainerUri, {\n      method: 'POST',\n      body: rawFile,\n      headers: new Headers({\n        // We must sluggify the file name, because we can't use non-ASCII characters in the header\n        // However we keep the extension apart (if it exists) so that it is not replaced with a -\n        // TODO let the middleware guess the extension based on the content type\n        Slug: getSlugWithExtension(rawFile.name),\n        'Content-Type': rawFile.type\n      })\n    });\n\n    if (response.status === 201) {\n      return response.headers.get('Location');\n    }\n  };\n\n  /*\n   * Look for raw files in the resource data.\n   * If there are any, upload them and replace the file by its URL.\n   */\n  const uploadAllFiles = async resource => {\n    for (let property in resource) {\n      if (resource.hasOwnProperty(property)) {\n        if (Array.isArray(resource[property])) {\n          for (let i = 0; i < resource[property].length; i++) {\n            if (isFile(resource[property][i])) {\n              resource[property][i] = await uploadFile(resource[property][i].rawFile);\n            }\n          }\n        } else {\n          if (isFile(resource[property])) {\n            resource[property] = await uploadFile(resource[property].rawFile);\n          }\n        }\n      }\n    }\n    return resource;\n  };\n\n  return {\n    getList: async (resourceId, params) => {\n      if (!resources[resourceId]) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n      if (params.id || params['@id'] || !resources[resourceId].types) {\n        const url = params.id || params['@id'] || resources[resourceId].containerUri;\n        let { json } = await httpClient(url);\n\n        if (isType('ldp:Container', json)) {\n          /*\n           * LDP Container\n           */\n          let returnData = json['ldp:contains'].map(item => {\n            item.id = item.id || item['@id'];\n            return item;\n          });\n\n          // Apply filter to results\n          if (params.filter) {\n            // Remove search params from filter\n            if (params.filter.q) {\n              delete params.filter.q;\n            }\n            if (Object.keys(params.filter).length > 0) {\n              returnData = returnData.filter(resource =>\n                Object.entries(params.filter).some(([k, v]) =>\n                  Array.isArray(resource[k]) ? resource[k].includes(v) : resource[k] === v\n                )\n              );\n            }\n          }\n\n          if (params.pagination) {\n            returnData = returnData.slice(\n              (params.pagination.page - 1) * params.pagination.perPage,\n              params.pagination.page * params.pagination.perPage\n            );\n          }\n\n          return { data: returnData, total: json['ldp:contains'].length };\n        } else {\n          /*\n           * ActivityPub collection\n           */\n\n          // If the collection is split amongst several pages, get the first page\n          if (json.first) {\n            const result = await httpClient(json.first);\n            json = result.json;\n          }\n\n          const listProperty = ['as:orderedItems', 'orderedItems', 'as:items', 'items'].find(p => json[p]);\n          if (!listProperty) return { data: [], total: 0 };\n\n          // TODO fetch several pages depending on params.pagination\n\n          let returnData = json[listProperty].map(item => {\n            item.id = item.id || item['@id'];\n            return item;\n          });\n\n          return { data: returnData, total: json.totalItems };\n        }\n      } else {\n        /*\n         * Do a SPARQL search\n         */\n        const sparqlQuery = buildSparqlQuery({\n          types: resources[resourceId].types,\n          params: { ...params, filter: { ...resources[resourceId].filter, ...params.filter } },\n          ontologies\n        });\n\n        let { json } = await httpClient(sparqlEndpoint, {\n          method: 'POST',\n          body: sparqlQuery\n        });\n\n        const total = json.length;\n\n        if (params.pagination) {\n          json = json.slice(\n            (params.pagination.page - 1) * params.pagination.perPage,\n            params.pagination.page * params.pagination.perPage\n          );\n        }\n\n        let data = await Promise.allSettled(json.map(\n          result => httpClient(result.resource.value).then(result => result.json)\n        ));\n\n        // Ignore resources we were not able to fetch\n        data = data.filter(r => r.status === 'fulfilled').map(r => r.value);\n\n        return { data, total }\n      }\n    },\n    getOne: async (resourceId, params) => {\n      if (!resources[resourceId]) {\n        Error(`Resource ${resourceId} is not mapped in resources file`);\n      }\n      const dataModel = resources[resourceId];\n\n      let { json } = await httpClient(params.id);\n      json.id = json.id || json['@id'];\n      // TODO compact only if remote context is different from local context\n      const compactJson = await jsonld.compact(json, jsonContext || buildJsonContext(ontologies));\n      // transform single value into array concidering forceArray predicates\n      if (dataModel.forceArray) {\n        for (const forceArrayItem of dataModel.forceArray) {\n          if (compactJson[forceArrayItem] && !Array.isArray(compactJson[forceArrayItem])) {\n            compactJson[forceArrayItem] = [compactJson[forceArrayItem]];\n          }\n        }\n      }\n      return { data: compactJson };\n    },\n    getMany: async (resourceId, params) => {\n      let returnData = [];\n\n      for (let id of params.ids) {\n        id = typeof id === 'object' ? id['@id'] : id;\n\n        try {\n          let { json } = await httpClient(id);\n          json.id = json.id || json['@id'];\n          returnData.push(json);\n        } catch (e) {\n          // Do nothing if one resource fails to load\n          // Otherwise no references will be show if only one is missing\n          // See https://github.com/marmelab/react-admin/issues/5190\n        }\n      }\n\n      return { data: returnData };\n    },\n    getManyReference: (resourceId, params) => {\n      throw new Error('getManyReference is not implemented yet');\n    },\n    create: async (resourceId, params) => {\n      if (!resources[resourceId]) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n      const { slugField, containerUri, types } = resources[resourceId];\n      const headers = new Headers();\n\n      if (slugField) {\n        headers.set(\n          'Slug',\n          Array.isArray(slugField) ? slugField.map(f => params.data[f]).join(' ') : params.data[slugField]\n        );\n      }\n\n      // Upload files, if there are any\n      params.data = await uploadAllFiles(params.data);\n\n      const { headers: responseHeaders } = await httpClient(containerUri, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          '@context': jsonContext || buildJsonContext(ontologies),\n          '@type': types,\n          ...params.data\n        })\n      });\n\n      // Retrieve newly-created resource\n      const resourceUri = responseHeaders.get('Location');\n      let { json } = await httpClient(resourceUri);\n      json.id = json.id || json['@id'];\n      return { data: json };\n    },\n    update: async (resourceId, params) => {\n      // Upload files, if there are any\n      params.data = await uploadAllFiles(params.data);\n      await httpClient(params.id, {\n        method: 'PUT',\n        body: JSON.stringify({\n          '@context': jsonContext || buildJsonContext(ontologies),\n          ...params.data\n        })\n      });\n\n      return { data: params.data };\n    },\n\n    updateMany: (resourceId, params) => {\n      throw new Error('updateMany is not implemented yet');\n    },\n    delete: async (resourceId, params) => {\n      await httpClient(params.id, {\n        method: 'DELETE'\n      });\n\n      return { data: { id: params.id } };\n    },\n    deleteMany: (resourceId, params) => {\n      throw new Error('deleteMany is not implemented yet');\n    }\n  };\n};\n\nexport default dataProvider;\n","import React from 'react';\nimport { DateTimeInput as RaDateTimeInput } from 'react-admin';\n\n/**\n * @deprecated Use the component from the @semapps/date-components instead\n */\nconst DateTimeInput = props => (\n  <RaDateTimeInput {...props} format={value => value && value.replace(' ', 'T').replace('Z', '')} />\n);\n\nexport default DateTimeInput;\n","import React from 'react';\nimport { useQueryWithStore } from 'react-admin';\nimport { default as FilterHandler } from './FilterHandler';\n\n/*\n * @example Label used in examples\n *  const Label = ({label, ...otherProps})=>{\n *     return <h2>{label}</h2>\n *  }\n *\n * @example show header for each group with group property thanks to groupHeader\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupHeader={({group,...otherProps}) => <Label {...otherProps} label={group['pair:label']}></Label> }\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example call chhildren with label thanks to groupLabel\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example conditional show of group if no data in source. Conditionale groupHeader is not possible because GroupedArrayField define group before filter ; need use chhildren.\n * const ConditionalSourceDefinedHandler = ({record,source,children,...otherProps})=>{\n *   if (record?.[source] && (!Array.isArray(record[source])||record[source].length>0)){\n *     return  React.Children.map(children, (child, i) => {\n *         return React.cloneElement(child, {...otherProps,record,source});\n *       })\n *   }else{\n *     return <></>\n *   }\n * }\n *\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *  <ConditionalSourceDefinedHandler>\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n *  </ConditionalSourceDefinedHandler>\n * </GroupedReferenceHandler>\n *\n *\n */\nconst GroupedReferenceHandler = ({\n  children,\n  groupReference,\n  groupLabel,\n  groupHeader,\n  filterProperty,\n  ...otherProps\n}) => {\n  const { data } = useQueryWithStore({\n    type: 'getList',\n    resource: groupReference,\n    payload: {}\n  });\n\n  return (\n    <>\n      {data?.map((data, index) => {\n        let filter = {};\n        filter[filterProperty] = data.id;\n        return (\n          <>\n            {groupHeader && groupHeader({ ...otherProps, group: data })}\n            <FilterHandler {...otherProps} filter={filter} label={data[groupLabel]}>\n              {children}\n            </FilterHandler>\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport default GroupedReferenceHandler;\n","import React from 'react';\nimport { ImageField as RaImageField } from 'react-admin';\n\nconst ImageField = ({ record, source, ...otherProps }) => {\n  // For the display, we need to have the URI in a src property\n  if (typeof record === 'string') record = { [source]: record };\n  return <RaImageField record={record} source={source} {...otherProps} />;\n};\n\nexport default ImageField;\n","import React from 'react';\nimport { ReferenceInput as RaReferenceInput, useResourceContext } from 'react-admin';\n\nconst ReferenceInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // If a format prop was defined, apply it\n        if (props.format) value = props.format(value);\n        // If the value is an object with an @id field, return the uri\n        return typeof value === 'object' ? value.id || value['@id'] : value;\n      }}\n    />\n  );\n};\n\nexport default ReferenceInput;\n","import { fetchUtils } from 'react-admin';\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) options.headers = new Headers();\n\n  switch (options.method) {\n    case 'POST':\n    case 'PATCH':\n    case 'PUT':\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      if (!options.headers.has('Content-Type')) options.headers.set('Content-Type', 'application/ld+json');\n      break;\n\n    case 'DELETE':\n      break;\n\n    case 'GET':\n    default:\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      break;\n  }\n\n  const token = localStorage.getItem('token');\n  if (token) options.headers.set('Authorization', `Bearer ${token}`);\n\n  return fetchUtils.fetchJson(url, options);\n};\n\nexport default httpClient;\n"],"names":["ReferenceArrayField","record","source","otherProps","Array","isArray","map","i","id","React","RaReferenceArrayField","defaultProps","addLabel","ReferenceField","_typeof","RaReferenceField","FilterHandler","children","filter","useState","filtered","setFiltered","useEffect","filteredData","r","eq","key","value","includes","newRecord","length","undefined","Children","child","cloneElement","ReferenceArrayInput","props","resource","useResourceContext","RaReferenceArrayInput","format","v","useReferenceInputStyles","makeStyles","form","display","input","paddingRight","useHideInputStyles","root","buildSparqlQuery","types","params","sort","ontologies","whereQuery","q","toLowerCase","Object","keys","forEach","predicate","object","startsWith","ontology","prefix","url","join","getPrefixRdf","field","order","createSlug","require","buildJsonContext","pattern","isFile","o","rawFile","File","RaDateTimeInput","replace","groupReference","groupLabel","groupHeader","filterProperty","data","useQueryWithStore","type","payload","index","group","label","RaImageField","RaReferenceInput","reificationClass","flexFormClasses","hideInputStyles","ArrayInput","SimpleFormIterator","classes","className","TextInput","initialValue","sparqlEndpoint","httpClient","resources","jsonContext","uploadsContainerUri","uploadFile","Error","method","body","headers","Headers","Slug","fileName","name","fileExtension","splitFileName","split","pop","lang","response","status","get","uploadAllFiles","property","hasOwnProperty","getList","resourceId","containerUri","json","resourceType","returnData","item","entries","some","k","pagination","slice","page","perPage","total","first","result","listProperty","find","p","totalItems","sparqlQuery","Promise","allSettled","then","getOne","dataModel","jsonld","compact","compactJson","forceArray","forceArrayItem","getMany","ids","push","getManyReference","create","slugField","set","f","JSON","stringify","responseHeaders","resourceUri","update","updateMany","deleteMany","options","has","token","localStorage","getItem","fetchUtils","fetchJson"],"mappings":"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"}