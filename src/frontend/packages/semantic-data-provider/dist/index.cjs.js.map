{"version":3,"file":"index.cjs.js","sources":["../src/fields/ReferenceArrayField.js","../src/fields/ReferenceField.js","../src/dataHandling/FilterHandler.js","../src/inputs/ReferenceArrayInput.js","../src/inputs/ReificationArrayInput.js","../src/dataProvider/methods/getOne.js","../src/dataProvider/utils/dereference.js","../src/dataProvider/utils/buildSparqlQuery.js","../src/dataProvider/utils/getRdfPrefixes.js","../src/dataProvider/utils/getEmbedFrame.js","../src/dataProvider/methods/getList.js","../src/dataProvider/methods/getMany.js","../src/dataProvider/utils/uploadAllFiles.js","../src/dataProvider/methods/create.js","../src/dataProvider/methods/update.js","../src/dataProvider/methods/delete.js","../src/inputs/DateTimeInput.js","../src/dataHandling/GroupedReferenceHandler.js","../src/fields/ImageField.js","../src/inputs/ReferenceInput.js","../src/dataProvider/dataProvider.js","../src/httpClient.js"],"sourcesContent":["import React from 'react';\nimport { ReferenceArrayField as RaReferenceArrayField } from 'react-admin';\n\nconst ReferenceArrayField = ({ record, source, ...otherProps }) => {\n  if (record?.[source]) {\n    if (!Array.isArray(record[source])) {\n      record[source] = [record[source]];\n    }\n    record[source] = record[source].map(i => i['@id'] || i.id || i);\n  }\n  return <RaReferenceArrayField record={record} source={source} {...otherProps} />;\n};\n\nReferenceArrayField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceArrayField;\n","import React from 'react';\nimport { ReferenceField as RaReferenceField } from 'react-admin';\n\nconst ReferenceField = ({ record, source, ...otherProps }) => {\n  if (record[source]) {\n    if (typeof record[source] === 'object') {\n      record[source] = record[source]['@id'] || record[source].id;\n    }\n  }\n  return <RaReferenceField record={record} source={source} {...otherProps} />;\n};\n\nReferenceField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceField;\n","import React, { useState, useEffect } from 'react';\n\n/**\n * @example\n * <Show>\n *   <FilterHandler\n *     source=\"property\" // ex pair:organizationOfMembership\n *     filter={{\n *       'propertyToFilter':'value'\n *     }} // ex {{'pair:membershipRole':'http://localhost:3000/membership-roles/role-1'}}\n *     >\n *     <SingleFieldList>\n *    </SingleFieldList>\n *   </FilterHandler>\n * </Show>\n */\n\nconst FilterHandler = ({ children, record, filter, source, ...otherProps }) => {\n  const [filtered, setFiltered] = useState();\n  useEffect(() => {\n    if (record && source && Array.isArray(record?.[source])) {\n      const filteredData = record?.[source].filter(r => {\n        let eq = true;\n        for (const key in filter) {\n          const value = r[key];\n          if (Array.isArray(value)) {\n            if (!value.includes(filter[key])) {\n              eq = false;\n            }\n          } else {\n            if (value !== filter[key]) {\n              eq = false;\n            }\n          }\n        }\n        return eq;\n      });\n      let newRecord = {\n        ...record\n      };\n      //undefined setted if no data to obtain no render in RightLabel or equivalent\n      newRecord[source] = filteredData.length > 0 ? filteredData : undefined;\n      setFiltered(newRecord);\n    }\n  }, [record, source, filter]);\n\n  return (\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          ...otherProps,\n          record: filtered,\n          addLabel: true,\n          source\n        });\n      })}\n    </>\n  );\n};\nexport default FilterHandler;\n","import React from 'react';\nimport { ReferenceArrayInput as RaReferenceArrayInput, useResourceContext } from 'react-admin';\n\nconst ReferenceArrayInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceArrayInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // if the linked field value is not an array, turns it into an array.\n        // Necessary as JSON-LD are sometimes arrays, sometimes not (when there is one value)\n        // and the ReferenceArrayInput component only accept arrays\n        if (!Array.isArray(value)) value = [value];\n        // If a format prop was defined, apply it to the array\n        if (props.format) value = props.format(value);\n        // If the values are objects with @id field, turn it to a simple string\n        return value.map(v => (typeof v === 'object' ? v.id || v['@id'] : v));\n      }}\n    />\n  );\n};\n\nexport default ReferenceArrayInput;\n","import React, { useEffect, useState } from 'react';\nimport { ArrayInput, SimpleFormIterator, TextInput } from 'react-admin';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useReferenceInputStyles = makeStyles({\n  form: {\n    display: 'flex'\n  },\n  input: {\n    paddingRight: '20px'\n  }\n});\n\nconst useHideInputStyles = makeStyles({\n  root: {\n    display: 'none'\n  }\n});\n\nconst ReificationArrayInput = props => {\n  const { reificationClass, children, ...otherProps } = props;\n  const flexFormClasses = useReferenceInputStyles();\n  const hideInputStyles = useHideInputStyles();\n\n  return (\n    <ArrayInput {...otherProps}>\n      <SimpleFormIterator classes={{ form: flexFormClasses.form }}>\n        {React.Children.map(props.children, (child, i) => {\n          return React.cloneElement(child, {\n            className: flexFormClasses.input\n          });\n        })}\n        <TextInput className={hideInputStyles.root} source=\"type\" initialValue={reificationClass} />\n      </SimpleFormIterator>\n    </ArrayInput>\n  );\n};\n\nexport default ReificationArrayInput;\n","import jsonld from \"jsonld\";\n\nconst getOneMethod = config => async (resourceId, params) => {\n  const { resources, httpClient, jsonContext } = config;\n\n  if (!resources[resourceId]) {\n    Error(`Resource ${resourceId} is not mapped in resources file`);\n  }\n\n  const { forceArray } = resources[resourceId];\n\n  let { json: data } = await httpClient(params.id);\n  data.id = data.id || data['@id'];\n\n  // We compact only if the context is different between the frontend and the middleware\n  // TODO deep compare if the context is an object\n  if( data['@context'] !== jsonContext ) {\n    data = await jsonld.compact(data, jsonContext);\n  }\n\n  // transform single value into array if forceArray is set\n  if (forceArray) {\n    for (const forceArrayItem of forceArray) {\n      if (data[forceArrayItem] && !Array.isArray(data[forceArrayItem])) {\n        data[forceArrayItem] = [data[forceArrayItem]];\n      }\n    }\n  }\n\n  return { data: data };\n};\n\nexport default getOneMethod;","// Return an object in the form of predicate => parentPredicate\nconst flattenPredicate = (accumulator, predicate, parent = 'root') => {\n  if (predicate.includes('/')) {\n    const matches = predicate.split(/\\/(.+)/);\n    accumulator[matches[0]] = parent;\n    flattenPredicate(accumulator, matches[1], matches[0]);\n  } else {\n    accumulator[predicate] = parent;\n  }\n  return accumulator;\n};\n\n// Transform ontology:predicate to OntologyPredicate in order to use it as a variable name\nconst generateSparqlVarName = predicate =>\n  predicate\n    .split(':')\n    .map(s => s[0].toUpperCase() + s.slice(1))\n    .join('');\n\nexport const buildDereferenceQuery = predicates => {\n  let queries = [];\n\n  if (predicates) {\n    const flattenedPredicates = predicates.reduce((acc, predicate) => flattenPredicate(acc, predicate), {});\n\n    for (const [predicate, parent] of Object.entries(flattenedPredicates)) {\n      const varName = generateSparqlVarName(predicate);\n      const parentVarName = parent === 'root' ? '1' : generateSparqlVarName(parent);\n\n      // Group queries by parent, so that we can group WHERE triples in the same OPTIONAL tag\n      const groupKey = parent === 'root' ? predicate : parent;\n      if (!queries[groupKey]) queries[groupKey] = [];\n\n      queries[groupKey].push(`\n        ?s${parentVarName} ${predicate} ?s${varName} .\n        ?s${varName} ?p${varName} ?o${varName} .\n      `);\n    }\n  }\n\n  return {\n    construct: Object.values(queries)\n      .map(groupedQueries => Object.values(groupedQueries).join('\\n'))\n      .join('\\n'),\n    where: Object.values(queries)\n      .map(groupedQueries => `OPTIONAL { ${Object.values(groupedQueries).join('\\n')} }`)\n      .join('\\n')\n  };\n};\n","import { buildDereferenceQuery } from './dereference';\nimport getRdfPrefixes from \"./getRdfPrefixes\";\n\nconst buildSparqlQuery = ({ types, params: { filter }, dereference, ontologies }) => {\n  let whereQuery = '';\n\n  if (filter) {\n    if (filter.q && filter.q.length > 0) {\n      whereQuery += `\n      {\n        SELECT ?s1\n        WHERE {\n          ?s1 ?p1 ?o1 .\n          FILTER regex(lcase(str(?o1)), \"${filter.q.toLowerCase()}\")\n          FILTER NOT EXISTS {?s1 a ?o1}\n        }\n      }\n      `;\n      delete filter.q;\n    }\n    Object.keys(filter).forEach(predicate => {\n      if (filter[predicate]) {\n        const object = filter[predicate].startsWith('http') ? `<${filter[predicate]}>` : filter[predicate];\n        whereQuery += `?s1 ${predicate} ${object} .`;\n      }\n    });\n  }\n\n  const dereferenceQuery = buildDereferenceQuery(dereference);\n\n  return `\n    ${getRdfPrefixes(ontologies)}\n    CONSTRUCT {\n      ?s1 ?p2 ?o2 .\n      ${dereferenceQuery.construct}\n    }\n    WHERE {\n      ?s1 a ?type .\n      FILTER( ?type IN (${types.join(', ')}) ) .\n      FILTER( (isIRI(?s1)) ) .\n      ${whereQuery}\n      ${dereferenceQuery.where}\n      ?s1 ?p2 ?o2 .\n    }\n  `;\n};\n\nexport default buildSparqlQuery;\n","const getRdfPrefixes = ontologies => {\n  return ontologies.map(ontology => `PREFIX ${ontology.prefix}: <${ontology.url}>`).join('\\n');\n};\n\nexport default getRdfPrefixes;\n","const getEmbedFrame = paths => {\n  let embedFrame = {},\n    predicates;\n  if (paths) {\n    for (let path of paths) {\n      if (path.includes('/')) {\n        predicates = path.split('/').reverse();\n      } else {\n        predicates = [path];\n      }\n      embedFrame = {\n        ...embedFrame,\n        ...predicates.reduce(\n          (accumulator, predicate) => ({\n            [predicate]: {\n              '@embed': '@last',\n              ...accumulator\n            }\n          }),\n          {}\n        )\n      };\n    }\n    return embedFrame;\n  }\n};\n\nexport default getEmbedFrame;\n","import buildSparqlQuery from \"../utils/buildSparqlQuery\";\nimport getEmbedFrame from \"../utils/getEmbedFrame\";\nimport jsonld from \"jsonld\";\n\nexport const isType = (type, resource) => {\n  const resourceType = resource.type || resource['@type'];\n  return Array.isArray(resourceType) ? resourceType.includes(type) : resourceType === type;\n};\n\nconst getListMethod = config => async (resourceId, params) => {\n  let {\n    sparqlEndpoint,\n    httpClient,\n    resources,\n    ontologies,\n    jsonContext\n  } = config;\n\n  if (!resources[resourceId]) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  if (params.id || params['@id'] || resources[resourceId].fetchContainer) {\n    const url = params.id || params['@id'] || resources[resourceId].containerUri;\n    let { json } = await httpClient(url);\n\n    if (isType('ldp:Container', json)) {\n      /*\n       * LDP Container\n       */\n      let returnData = json['ldp:contains'].map(item => {\n        item.id = item.id || item['@id'];\n        return item;\n      });\n\n      // Apply filter to results\n      if (params.filter) {\n        // Remove search params from filter\n        if (params.filter.q) {\n          delete params.filter.q;\n        }\n        if (Object.keys(params.filter).length > 0) {\n          returnData = returnData.filter(resource =>\n            Object.entries(params.filter).some(([k, v]) =>\n              Array.isArray(resource[k]) ? resource[k].includes(v) : resource[k] === v\n            )\n          );\n        }\n      }\n\n      if (params.sort) {\n        returnData = returnData.sort((a, b) => {\n          if (a[params.sort.field] && b[params.sort.field]) {\n            if (params.sort.order === 'ASC') {\n              return a[params.sort.field].localeCompare(b[params.sort.field]);\n            } else {\n              return b[params.sort.field].localeCompare(a[params.sort.field]);\n            }\n          } else {\n            return true;\n          }\n        });\n      }\n      if (params.pagination) {\n        returnData = returnData.slice(\n          (params.pagination.page - 1) * params.pagination.perPage,\n          params.pagination.page * params.pagination.perPage\n        );\n      }\n\n      return { data: returnData, total: json['ldp:contains'].length };\n    } else {\n      /*\n       * ActivityPub collection\n       */\n\n      // If the collection is split amongst several pages, get the first page\n      if (json.first) {\n        const result = await httpClient(json.first);\n        json = result.json;\n      }\n\n      const listProperty = ['as:orderedItems', 'orderedItems', 'as:items', 'items'].find(p => json[p]);\n      if (!listProperty) return { data: [], total: 0 };\n\n      // TODO fetch several pages depending on params.pagination\n\n      let returnData = json[listProperty].map(item => {\n        item.id = item.id || item['@id'];\n        return item;\n      });\n\n      return { data: returnData, total: json.totalItems };\n    }\n  } else {\n    const sparqlQuery = buildSparqlQuery({\n      types: resources[resourceId].types,\n      params: { ...params, filter: { ...resources[resourceId].filter, ...params.filter } },\n      dereference: resources[resourceId].dereference,\n      ontologies\n    });\n\n    const { json } = await httpClient(sparqlEndpoint, {\n      method: 'POST',\n      body: sparqlQuery\n    });\n\n    const frame = {\n      '@context': jsonContext,\n      '@type': resources[resourceId].types,\n      // Embed only what we explicitly asked to dereference\n      // Otherwise we may have same-type resources embedded in other resources\n      '@embed': '@never',\n      ...getEmbedFrame(resources[resourceId].dereference)\n    };\n\n    // omitGraph option force results to be in a @graph, even if we have a single result\n    const compactJson = await jsonld.frame(json, frame, { omitGraph: false });\n\n    if (Object.keys(compactJson).length === 1) {\n      // If we have only the context, it means there is no match\n      return { data: [], total: 0 };\n    } else {\n      // Add id in addition to @id, as this is what React-Admin expects\n      let returnData = compactJson['@graph'].map(item => {\n        item.id = item.id || item['@id'];\n        return item;\n      });\n\n      if (params.sort) {\n        returnData = returnData.sort((a, b) => {\n          if (a[params.sort.field] && b[params.sort.field]) {\n            if (params.sort.order === 'ASC') {\n              return a[params.sort.field].localeCompare(b[params.sort.field]);\n            } else {\n              return b[params.sort.field].localeCompare(a[params.sort.field]);\n            }\n          } else {\n            return true;\n          }\n        });\n      }\n      if (params.pagination) {\n        returnData = returnData.slice(\n          (params.pagination.page - 1) * params.pagination.perPage,\n          params.pagination.page * params.pagination.perPage\n        );\n      }\n\n      return { data: returnData, total: compactJson['@graph'].length };\n    }\n\n    // OTHER METHOD: FETCH ONLY RESOURCES URIs AND FETCH THEM INDEPENDENTLY\n    // TODO compare the performance of the two methods, and eventually allow both of them\n    //\n    // const sparqlQuery = buildSparqlUriQuery({\n    //   types: resources[resourceId].types,\n    //   params: { ...params, filter: { ...resources[resourceId].filter, ...params.filter } },\n    //   ontologies\n    // });\n    //\n    // let { json } = await httpClient(sparqlEndpoint, {\n    //   method: 'POST',\n    //   body: sparqlQuery\n    // });\n    //\n    // const total = json.length;\n    //\n    // if (params.pagination) {\n    //   json = json.slice(\n    //     (params.pagination.page - 1) * params.pagination.perPage,\n    //     params.pagination.page * params.pagination.perPage\n    //   );\n    // }\n    //\n    // let data = await Promise.allSettled(\n    //   json.map(result => httpClient(result.resource.value).then(result => result.json))\n    // );\n    //\n    // // Ignore resources we were not able to fetch\n    // data = data.filter(r => r.status === 'fulfilled').map(r => r.value);\n    //\n    // return { data, total };\n  }\n};\n\nexport default getListMethod;\n","import getOne from \"./getOne\";\n\nconst getManyMethod = config => async (resourceId, params) => {\n  const { returnFailedResources } = config;\n\n  let returnData = [];\n\n  for (let id of params.ids) {\n    id = typeof id === 'object' ? id['@id'] : id;\n\n    try {\n      const data = await getOne(config)(resourceId, { id });\n      returnData.push(data);\n    } catch (e) {\n      // Catch if one resource fails to load\n      // Otherwise no references will be show if only one is missing\n      // See https://github.com/marmelab/react-admin/issues/5190\n      if (returnFailedResources) {\n        // Return only the ID of the resource\n        returnData.push({ id });\n      } else {\n        // Do nothing. The resource will not appear in the results.\n      }\n    }\n  }\n\n  return { data: returnData };\n};\n\nexport default getManyMethod;\n","import createSlug from \"speakingurl\";\n\nexport const getSlugWithExtension = fileName => {\n  let fileExtension = '';\n  let splitFileName = fileName.split('.');\n  if (splitFileName.length > 1) {\n    fileExtension = splitFileName.pop();\n    fileName = splitFileName.join('.');\n  }\n  return createSlug(fileName, { lang: 'fr' }) + '.' + fileExtension;\n};\n\nexport const isFile = o => o && o.rawFile && o.rawFile instanceof File;\n\nconst uploadFile = async (rawFile, config) => {\n  const response = await config.httpClient(config.uploadsContainerUri, {\n    method: 'POST',\n    body: rawFile,\n    headers: new Headers({\n      // We must sluggify the file name, because we can't use non-ASCII characters in the header\n      // However we keep the extension apart (if it exists) so that it is not replaced with a -\n      // TODO let the middleware guess the extension based on the content type\n      Slug: getSlugWithExtension(rawFile.name),\n      'Content-Type': rawFile.type\n    })\n  });\n\n  if (response.status === 201) {\n    return response.headers.get('Location');\n  }\n};\n\n/*\n * Look for raw files in the record data.\n * If there are any, upload them and replace the file by its URL.\n */\nconst uploadAllFiles = async (record, config) => {\n  if (!config.uploadsContainerUri) throw new Error('No uploadsContainerUri defined for the data provider');\n  \n  for (let property in record) {\n    if (record.hasOwnProperty(property)) {\n      if (Array.isArray(record[property])) {\n        for (let i = 0; i < record[property].length; i++) {\n          if (isFile(record[property][i])) {\n            record[property][i] = await uploadFile(record[property][i].rawFile, config);\n          }\n        }\n      } else {\n        if (isFile(record[property])) {\n          record[property] = await uploadFile(record[property].rawFile, config);\n        }\n      }\n    }\n  }\n  return record;\n};\n\nexport default uploadAllFiles;\n","import uploadAllFiles from \"../utils/uploadAllFiles\";\nimport getOne from \"./getOne\";\n\nconst createMethod = config => async (resourceId, params) => {\n  const { resources, httpClient, jsonContext } = config;\n\n  if (!resources[resourceId]) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const { slugField, containerUri, types } = resources[resourceId];\n  const headers = new Headers();\n\n  if (slugField) {\n    headers.set(\n      'Slug',\n      Array.isArray(slugField) ? slugField.map(f => params.data[f]).join(' ') : params.data[slugField]\n    );\n  }\n\n  // Upload files, if there are any\n  params.data = await uploadAllFiles(params.data, config);\n\n  const { headers: responseHeaders } = await httpClient(containerUri, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n      '@context': jsonContext,\n      '@type': types,\n      ...params.data\n    })\n  });\n\n  // Retrieve newly-created resource\n  const resourceUri = responseHeaders.get('Location');\n  return await getOne(config)(resourceId, { id: resourceUri });\n};\n\nexport default createMethod;\n","import uploadAllFiles from \"../utils/uploadAllFiles\";\n\nconst updateMethod = config => async (resourceId, params) => {\n  const { httpClient, jsonContext } = config;\n\n  // Upload files, if there are any\n  params.data = await uploadAllFiles(params.data, config);\n\n  await httpClient(params.id, {\n    method: 'PUT',\n    body: JSON.stringify({\n      '@context': jsonContext,\n      ...params.data\n    })\n  });\n\n  return { data: params.data };\n};\n\nexport default updateMethod;\n","const deleteMethod = config => async (resourceId, params) => {\n  const { httpClient } = config;\n\n  await httpClient(params.id, {\n    method: 'DELETE'\n  });\n\n  return { data: { id: params.id } };\n};\n\nexport default deleteMethod;\n","import React from 'react';\nimport { DateTimeInput as RaDateTimeInput } from 'react-admin';\n\n/**\n * @deprecated Use the component from the @semapps/date-components instead\n */\nconst DateTimeInput = props => (\n  <RaDateTimeInput {...props} format={value => value && value.replace(' ', 'T').replace('Z', '')} />\n);\n\nexport default DateTimeInput;\n","import React from 'react';\nimport { useQueryWithStore } from 'react-admin';\nimport { default as FilterHandler } from './FilterHandler';\n\n/*\n * @example Label used in examples\n *  const Label = ({label, ...otherProps})=>{\n *     return <h2>{label}</h2>\n *  }\n *\n * @example show header for each group with group property thanks to groupHeader\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupHeader={({group,...otherProps}) => <Label {...otherProps} label={group['pair:label']}></Label> }\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example call chhildren with label thanks to groupLabel\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example conditional show of group if no data in source. Conditionale groupHeader is not possible because GroupedArrayField define group before filter ; need use chhildren.\n * const ConditionalSourceDefinedHandler = ({record,source,children,...otherProps})=>{\n *   if (record?.[source] && (!Array.isArray(record[source])||record[source].length>0)){\n *     return  React.Children.map(children, (child, i) => {\n *         return React.cloneElement(child, {...otherProps,record,source});\n *       })\n *   }else{\n *     return <></>\n *   }\n * }\n *\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *  <ConditionalSourceDefinedHandler>\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n *  </ConditionalSourceDefinedHandler>\n * </GroupedReferenceHandler>\n *\n *\n */\nconst GroupedReferenceHandler = ({\n  children,\n  groupReference,\n  groupLabel,\n  groupHeader,\n  filterProperty,\n  ...otherProps\n}) => {\n  const { data } = useQueryWithStore({\n    type: 'getList',\n    resource: groupReference,\n    payload: {}\n  });\n\n  return (\n    <>\n      {data?.map((data, index) => {\n        let filter = {};\n        filter[filterProperty] = data.id;\n        return (\n          <>\n            {groupHeader && groupHeader({ ...otherProps, group: data })}\n            <FilterHandler {...otherProps} filter={filter} label={data[groupLabel]}>\n              {children}\n            </FilterHandler>\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport default GroupedReferenceHandler;\n","import React from 'react';\nimport { ImageField as RaImageField } from 'react-admin';\n\nconst ImageField = ({ record, source, ...otherProps }) => {\n  // For the display, we need to have the URI in a src property\n  if (typeof record === 'string') record = { [source]: record };\n  return <RaImageField record={record} source={source} {...otherProps} />;\n};\n\nexport default ImageField;\n","import React from 'react';\nimport { ReferenceInput as RaReferenceInput, useResourceContext } from 'react-admin';\n\nconst ReferenceInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // If a format prop was defined, apply it\n        if (props.format) value = props.format(value);\n        // If the value is an object with an @id field, return the uri\n        return typeof value === 'object' ? value.id || value['@id'] : value;\n      }}\n    />\n  );\n};\n\nexport default ReferenceInput;\n","import getOneMethod from \"./methods/getOne\";\nimport getListMethod from \"./methods/getList\";\nimport getManyMethod from \"./methods/getMany\";\nimport createMethod from \"./methods/create\";\nimport updateMethod from \"./methods/update\";\nimport deleteMethod from \"./methods/delete\";\n\nconst dataProvider = config => {\n  // TODO verify all data provider config + data models\n\n  if( !config.jsonContext ) config.jsonContext = Object.fromEntries(config.ontologies.map(o => [o.prefix, o.url]));\n  if( !config.returnFailedResources ) config.returnFailedResources = false;\n\n  return {\n    getList: getListMethod(config),\n    getOne: getOneMethod(config),\n    getMany: getManyMethod(config),\n    getManyReference: () => { throw new Error('getManyReference is not implemented yet') },\n    create: createMethod(config),\n    update: updateMethod(config),\n    updateMany: () => { throw new Error('updateMany is not implemented yet') },\n    delete: deleteMethod(config),\n    deleteMany: () => { throw new Error('deleteMany is not implemented yet') }\n  };\n};\n\nexport default dataProvider;\n","import { fetchUtils } from 'react-admin';\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) options.headers = new Headers();\n\n  switch (options.method) {\n    case 'POST':\n    case 'PATCH':\n    case 'PUT':\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      if (!options.headers.has('Content-Type')) options.headers.set('Content-Type', 'application/ld+json');\n      break;\n\n    case 'DELETE':\n      break;\n\n    case 'GET':\n    default:\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      break;\n  }\n\n  const token = localStorage.getItem('token');\n  if (token) options.headers.set('Authorization', `Bearer ${token}`);\n\n  return fetchUtils.fetchJson(url, options);\n};\n\nexport default httpClient;\n"],"names":["ReferenceArrayField","record","source","otherProps","Array","isArray","map","i","id","React","RaReferenceArrayField","defaultProps","addLabel","ReferenceField","_typeof","RaReferenceField","FilterHandler","children","filter","useState","filtered","setFiltered","useEffect","filteredData","r","eq","key","value","includes","newRecord","length","undefined","Children","child","cloneElement","ReferenceArrayInput","props","resource","useResourceContext","RaReferenceArrayInput","format","v","useReferenceInputStyles","makeStyles","form","display","input","paddingRight","useHideInputStyles","root","getOneMethod","config","resourceId","params","resources","httpClient","jsonContext","forceArray","data","json","jsonld","compact","forceArrayItem","generateSparqlVarName","predicate","split","s","toUpperCase","slice","join","buildSparqlQuery","types","dereference","ontologies","whereQuery","q","toLowerCase","Object","keys","forEach","object","startsWith","dereferenceQuery","predicates","queries","flattenedPredicates","reduce","acc","flattenPredicate","accumulator","parent","matches","entries","varName","parentVarName","groupKey","push","construct","values","groupedQueries","where","buildDereferenceQuery","ontology","prefix","url","getRdfPrefixes","getEmbedFrame","paths","embedFrame","path","reverse","getListMethod","sparqlEndpoint","fetchContainer","containerUri","type","resourceType","returnData","item","some","k","sort","a","b","field","order","localeCompare","pagination","page","perPage","total","first","result","listProperty","find","p","totalItems","sparqlQuery","method","body","frame","omitGraph","compactJson","getManyMethod","returnFailedResources","ids","getOne","isFile","o","rawFile","File","uploadFile","uploadsContainerUri","headers","Headers","Slug","fileName","name","fileExtension","splitFileName","pop","createSlug","lang","response","status","get","uploadAllFiles","Error","property","hasOwnProperty","createMethod","slugField","set","f","JSON","stringify","responseHeaders","resourceUri","updateMethod","deleteMethod","RaDateTimeInput","replace","groupReference","groupLabel","groupHeader","filterProperty","useQueryWithStore","payload","index","group","label","RaImageField","RaReferenceInput","reificationClass","flexFormClasses","hideInputStyles","ArrayInput","SimpleFormIterator","classes","className","TextInput","initialValue","fromEntries","getList","getMany","getManyReference","create","update","updateMany","deleteMany","options","has","token","localStorage","getItem","fetchUtils","fetchJson"],"mappings":"qkHAGMA,EAAsB,gBAAGC,IAAAA,OAAQC,IAAAA,OAAWC,kCAC5CF,MAAAA,SAAAA,EAASC,MACNE,MAAMC,QAAQJ,EAAOC,MACxBD,EAAOC,GAAU,CAACD,EAAOC,KAE3BD,EAAOC,GAAUD,EAAOC,GAAQI,KAAI,SAAAC,UAAKA,EAAE,QAAUA,EAAEC,IAAMD,MAExDE,gBAACC,yBAAsBT,OAAQA,EAAQC,OAAQA,GAAYC,KAGpEH,EAAoBW,aAAe,CACjCC,UAAU,OCXNC,EAAiB,gBAAGZ,IAAAA,OAAQC,IAAAA,OAAWC,kCACvCF,EAAOC,IACqB,WAA1BY,EAAOb,EAAOC,MAChBD,EAAOC,GAAUD,EAAOC,GAAQ,QAAUD,EAAOC,GAAQM,IAGtDC,gBAACM,oBAAiBd,OAAQA,EAAQC,OAAQA,GAAYC,KAG/DU,EAAeF,aAAe,CAC5BC,UAAU,OCINI,EAAgB,gBAAGC,IAAAA,SAAUhB,IAAAA,OAAQiB,IAAAA,OAAQhB,IAAAA,OAAWC,mDAC5BgB,gBAAzBC,OAAUC,cACjBC,aAAU,cACJrB,GAAUC,GAAUE,MAAMC,QAAQJ,MAAAA,SAAAA,EAASC,IAAU,KACjDqB,EAAetB,MAAAA,SAAAA,EAASC,GAAQgB,QAAO,SAAAM,OACvCC,GAAK,MACJ,IAAMC,KAAOR,EAAQ,KAClBS,EAAQH,EAAEE,GACZtB,MAAMC,QAAQsB,GACXA,EAAMC,SAASV,EAAOQ,MACzBD,GAAK,GAGHE,IAAUT,EAAOQ,KACnBD,GAAK,UAIJA,KAELI,OACC5B,GAGL4B,EAAU3B,GAAUqB,EAAaO,OAAS,EAAIP,OAAeQ,EAC7DV,EAAYQ,MAEb,CAAC5B,EAAQC,EAAQgB,IAGlBT,gCACGA,EAAMuB,SAAS1B,IAAIW,GAAU,SAACgB,EAAO1B,UAC7BE,EAAMyB,aAAaD,SACrB9B,OACHF,OAAQmB,EACRR,UAAU,EACVV,OAAAA,UClDJiC,EAAsB,SAAAC,OACpBC,EAAWC,qBAAmB,WAElC7B,gBAAC8B,2BACKH,GACJC,SAAUA,EACVG,OAAQ,SAAAb,UAEDA,GAIAvB,MAAMC,QAAQsB,KAAQA,EAAQ,CAACA,IAEhCS,EAAMI,SAAQb,EAAQS,EAAMI,OAAOb,IAEhCA,EAAMrB,KAAI,SAAAmC,SAAmB,WAAb3B,EAAO2B,GAAiBA,EAAEjC,IAAMiC,EAAE,OAASA,MAR/Cd,OCPrBe,EAA0BC,aAAW,CACzCC,KAAM,CACJC,QAAS,QAEXC,MAAO,CACLC,aAAc,UAIZC,EAAqBL,aAAW,CACpCM,KAAM,CACJJ,QAAS,UCbPK,EAAe,SAAAC,sDAAU,WAAOC,EAAYC,gHACxCC,EAAuCH,EAAvCG,UAAWC,EAA4BJ,EAA5BI,WAAYC,EAAgBL,EAAhBK,YAE1BF,EAAUF,GAIPK,EAAeH,EAAUF,GAAzBK,oBAEmBF,EAAWF,EAAO7C,wBAAjCkD,IAANC,MACDnD,GAAKkD,EAAKlD,IAAMkD,EAAK,OAItBA,EAAK,cAAgBF,oCACVI,EAAOC,QAAQH,EAAMF,WAAlCE,oBAIED,EAAY,KACeA,kCAAlBK,UACLJ,EAAKI,KAAoB1D,MAAMC,QAAQqD,EAAKI,MAC9CJ,EAAKI,GAAkB,CAACJ,EAAKI,6DAK5B,CAAEJ,KAAMA,yGChBXK,EAAwB,SAAAC,UAC5BA,EACGC,MAAM,KACN3D,KAAI,SAAA4D,UAAKA,EAAE,GAAGC,cAAgBD,EAAEE,MAAM,MACtCC,KAAK,KCdJC,EAAmB,gBAAGC,IAAAA,MAAiBrD,IAAVmC,OAAUnC,OAAUsD,IAAAA,YAAaC,IAAAA,WAC9DC,EAAa,GAEbxD,IACEA,EAAOyD,GAAKzD,EAAOyD,EAAE7C,OAAS,IAChC4C,+HAKqCxD,EAAOyD,EAAEC,gGAKvC1D,EAAOyD,GAEhBE,OAAOC,KAAK5D,GAAQ6D,SAAQ,SAAAf,MACtB9C,EAAO8C,GAAY,KACfgB,EAAS9D,EAAO8C,GAAWiB,WAAW,mBAAc/D,EAAO8C,QAAgB9C,EAAO8C,GACxFU,iBAAqBV,cAAagB,iBAKlCE,EDT6B,SAAAC,OAC/BC,EAAU,MAEVD,UACIE,EAAsBF,EAAWG,QAAO,SAACC,EAAKvB,UAtB/B,SAAnBwB,EAAoBC,EAAazB,OAAW0B,yDAAS,UACrD1B,EAAUpC,SAAS,KAAM,KACrB+D,EAAU3B,EAAUC,MAAM,UAChCwB,EAAYE,EAAQ,IAAMD,EAC1BF,EAAiBC,EAAaE,EAAQ,GAAIA,EAAQ,SAElDF,EAAYzB,GAAa0B,SAEpBD,EAc6DD,CAAiBD,EAAKvB,KAAY,UAElEa,OAAOe,QAAQP,kBAAsB,iBAA3DrB,OAAW0B,OACfG,EAAU9B,EAAsBC,GAChC8B,EAA2B,SAAXJ,EAAoB,IAAM3B,EAAsB2B,GAGhEK,EAAsB,SAAXL,EAAoB1B,EAAY0B,EAC5CN,EAAQW,KAAWX,EAAQW,GAAY,IAE5CX,EAAQW,GAAUC,2BACZF,cAAiB9B,gBAAe6B,2BAChCA,gBAAaA,gBAAaA,uBAK7B,CACLI,UAAWpB,OAAOqB,OAAOd,GACtB9E,KAAI,SAAA6F,UAAkBtB,OAAOqB,OAAOC,GAAgB9B,KAAK,SACzDA,KAAK,MACR+B,MAAOvB,OAAOqB,OAAOd,GAClB9E,KAAI,SAAA6F,8BAAgCtB,OAAOqB,OAAOC,GAAgB9B,KAAK,eACvEA,KAAK,OClBegC,CAAsB7B,yBC5B1B,SAAAC,UACdA,EAAWnE,KAAI,SAAAgG,0BAAsBA,EAASC,qBAAYD,EAASE,YAAQnC,KAAK,MD8BnFoC,CAAehC,4DAGbS,EAAiBe,wFAIC1B,EAAMF,KAAK,8DAE7BK,qBACAQ,EAAiBkB,2CEzCnBM,EAAgB,SAAAC,OAElBxB,EADEyB,EAAa,MAEbD,EAAO,WACQA,kCAAO,KAAfE,UAEL1B,EADE0B,EAAKjF,SAAS,KACHiF,EAAK5C,MAAM,KAAK6C,UAEhB,CAACD,GAEhBD,SACKA,GACAzB,EAAWG,QACZ,SAACG,EAAazB,eACXA,cACW,SACPyB,MAGP,2CAICmB,ICdLG,EAAgB,SAAA5D,sDAAU,WAAOC,EAAYC,8HAE/C2D,EAKE7D,EALF6D,eACAzD,EAIEJ,EAJFI,WACAD,EAGEH,EAHFG,UACAmB,EAEEtB,EAFFsB,WACAjB,EACEL,EADFK,YAGGF,EAAUF,KAEXC,EAAO7C,IAAM6C,EAAO,QAAUC,EAAUF,GAAY6D,wCAChDT,EAAMnD,EAAO7C,IAAM6C,EAAO,QAAUC,EAAUF,GAAY8D,sBAC3C3D,EAAWiD,sBAA1B7C,IAAAA,KAlBawD,EAoBR,gBAnBPC,OAAAA,EAAAA,GADqB/E,EAoBGsB,GAnBAwD,MAAQ9E,EAAS,WACxCjC,MAAMC,QAAQ+G,GAAgBA,EAAaxF,SAASuF,GAAQC,IAAiBD,2BAsB5EE,EAAa1D,EAAK,gBAAgBrD,KAAI,SAAAgH,UACxCA,EAAK9G,GAAK8G,EAAK9G,IAAM8G,EAAK,OACnBA,KAILjE,EAAOnC,SAELmC,EAAOnC,OAAOyD,UACTtB,EAAOnC,OAAOyD,EAEnBE,OAAOC,KAAKzB,EAAOnC,QAAQY,OAAS,IACtCuF,EAAaA,EAAWnG,QAAO,SAAAmB,UAC7BwC,OAAOe,QAAQvC,EAAOnC,QAAQqG,MAAK,yBAAEC,OAAG/E,cACtCrC,MAAMC,QAAQgC,EAASmF,IAAMnF,EAASmF,GAAG5F,SAASa,GAAKJ,EAASmF,KAAO/E,UAM3EY,EAAOoE,OACTJ,EAAaA,EAAWI,MAAK,SAACC,EAAGC,UAC3BD,EAAErE,EAAOoE,KAAKG,SAAUD,EAAEtE,EAAOoE,KAAKG,SACd,QAAtBvE,EAAOoE,KAAKI,MACPH,EAAErE,EAAOoE,KAAKG,OAAOE,cAAcH,EAAEtE,EAAOoE,KAAKG,QAEjDD,EAAEtE,EAAOoE,KAAKG,OAAOE,cAAcJ,EAAErE,EAAOoE,KAAKG,aAO5DvE,EAAO0E,aACTV,EAAaA,EAAWjD,OACrBf,EAAO0E,WAAWC,KAAO,GAAK3E,EAAO0E,WAAWE,QACjD5E,EAAO0E,WAAWC,KAAO3E,EAAO0E,WAAWE,4BAIxC,CAAEvE,KAAM2D,EAAYa,MAAOvE,EAAK,gBAAgB7B,qBAOnD6B,EAAKwE,wCACc5E,EAAWI,EAAKwE,eAA/BC,SACNzE,EAAOyE,EAAOzE,gBAGV0E,EAAe,CAAC,kBAAmB,eAAgB,WAAY,SAASC,MAAK,SAAAC,UAAK5E,EAAK4E,gDACnE,CAAE7E,KAAM,GAAIwE,MAAO,mBAIzCb,EAAa1D,EAAK0E,GAAc/H,KAAI,SAAAgH,UACtCA,EAAK9G,GAAK8G,EAAK9G,IAAM8G,EAAK,OACnBA,uBAGF,CAAE5D,KAAM2D,EAAYa,MAAOvE,EAAK6E,oDAGnCC,EAAcnE,EAAiB,CACnCC,MAAOjB,EAAUF,GAAYmB,MAC7BlB,cAAaA,OAAQnC,cAAaoC,EAAUF,GAAYlC,QAAWmC,EAAOnC,UAC1EsD,YAAalB,EAAUF,GAAYoB,YACnCC,WAAAA,cAGqBlB,EAAWyD,EAAgB,CAChD0B,OAAQ,OACRC,KAAMF,4BAFA9E,IAAAA,KAKFiF,gBACQpF,UACHF,EAAUF,GAAYmB,eAGrB,UACPmC,EAAcpD,EAAUF,GAAYoB,wBAIfZ,EAAOgF,MAAMjF,EAAMiF,EAAO,CAAEC,WAAW,eAA3DC,SAEkC,IAApCjE,OAAOC,KAAKgE,GAAahH,iDAEpB,CAAE4B,KAAM,GAAIwE,MAAO,mBAGtBb,EAAayB,EAAY,UAAUxI,KAAI,SAAAgH,UACzCA,EAAK9G,GAAK8G,EAAK9G,IAAM8G,EAAK,OACnBA,KAGLjE,EAAOoE,OACTJ,EAAaA,EAAWI,MAAK,SAACC,EAAGC,UAC3BD,EAAErE,EAAOoE,KAAKG,SAAUD,EAAEtE,EAAOoE,KAAKG,SACd,QAAtBvE,EAAOoE,KAAKI,MACPH,EAAErE,EAAOoE,KAAKG,OAAOE,cAAcH,EAAEtE,EAAOoE,KAAKG,QAEjDD,EAAEtE,EAAOoE,KAAKG,OAAOE,cAAcJ,EAAErE,EAAOoE,KAAKG,aAO5DvE,EAAO0E,aACTV,EAAaA,EAAWjD,OACrBf,EAAO0E,WAAWC,KAAO,GAAK3E,EAAO0E,WAAWE,QACjD5E,EAAO0E,WAAWC,KAAO3E,EAAO0E,WAAWE,4BAIxC,CAAEvE,KAAM2D,EAAYa,MAAOY,EAAY,UAAUhH,2CA/IxC,IAACqF,EAAM9E,EACrB+E,oECHF2B,EAAgB,SAAA5F,sDAAU,WAAOC,EAAYC,mGACzC2F,EAA0B7F,EAA1B6F,sBAEJ3B,EAAa,OAEFhE,EAAO4F,qEACpBzI,EAAmB,WAAdM,EADEN,WACuBA,EAAG,OAASA,qBAGrB0I,EAAO/F,EAAP+F,CAAe9F,EAAY,CAAE5C,GAAAA,YAA1CkD,SACN2D,EAAWrB,KAAKtC,qDAKZsF,GAEF3B,EAAWrB,KAAK,CAAExF,GAAAA,4KAOjB,CAAEkD,KAAM2D,oICdJ8B,EAAS,SAAAC,UAAKA,GAAKA,EAAEC,SAAWD,EAAEC,mBAAmBC,MAE5DC,8CAAa,WAAOF,EAASlG,yGACVA,EAAOI,WAAWJ,EAAOqG,oBAAqB,CACnEd,OAAQ,OACRC,KAAMU,EACNI,QAAS,IAAIC,QAAQ,CAInBC,MApB8BC,EAoBHP,EAAQQ,KAnBnCC,OAAAA,EACAC,OAAAA,EADAD,EAAgB,GAChBC,EAAgBH,EAAS3F,MAAM,KAC/B8F,EAAcjI,OAAS,IACzBgI,EAAgBC,EAAcC,MAC9BJ,EAAWG,EAAc1F,KAAK,MAEzB4F,EAAWL,EAAU,CAAEM,KAAM,OAAU,IAAMJ,kBAchCT,EAAQlC,mBAIJ,OAZlBgD,UAYOC,gDACJD,EAASV,QAAQY,IAAI,8CA1BI,IAAAT,EAC9BE,EACAC,mEAgCAO,8CAAiB,WAAOrK,EAAQkD,8FAC/BA,EAAOqG,0CAA2B,IAAIe,MAAM,4FAE5BtK,oDAAZuK,cACHvK,EAAOwK,eAAeD,wBACpBpK,MAAMC,QAAQJ,EAAOuK,qBACdjK,EAAI,cAAGA,EAAIN,EAAOuK,GAAU1I,6BAC/BqH,EAAOlJ,EAAOuK,GAAUjK,sCACEgJ,EAAWtJ,EAAOuK,GAAUjK,GAAG8I,QAASlG,WAApElD,EAAOuK,GAAUjK,kBAFwBA,uDAMzC4I,EAAOlJ,EAAOuK,sCACSjB,EAAWtJ,EAAOuK,GAAUnB,QAASlG,WAA9DlD,EAAOuK,kEAKRvK,uGCnDHyK,EAAe,SAAAvH,sDAAU,WAAOC,EAAYC,oHACxCC,EAAuCH,EAAvCG,UAAWC,EAA4BJ,EAA5BI,WAAYC,EAAgBL,EAAhBK,YAE1BF,EAAUF,KAE4BE,EAAUF,GAA7CuH,IAAAA,UAAWzD,IAAAA,aAAc3C,IAAAA,MAC3BkF,EAAU,IAAIC,QAEhBiB,GACFlB,EAAQmB,IACN,OACAxK,MAAMC,QAAQsK,GAAaA,EAAUrK,KAAI,SAAAuK,UAAKxH,EAAOK,KAAKmH,MAAIxG,KAAK,KAAOhB,EAAOK,KAAKiH,aAKtEL,EAAejH,EAAOK,KAAMP,iBAAhDE,EAAOK,sBAEoCH,EAAW2D,EAAc,CAClEwB,OAAQ,OACRe,QAAAA,EACAd,KAAMmC,KAAKC,wBACGvH,UACHe,GACNlB,EAAOK,iCANGsH,IAATvB,QAWFwB,EAAcD,EAAgBX,IAAI,sBAC3BnB,EAAO/F,EAAP+F,CAAe9F,EAAY,CAAE5C,GAAIyK,kJC/B1CC,EAAe,SAAA/H,sDAAU,WAAOC,EAAYC,kGACxCE,EAA4BJ,EAA5BI,WAAYC,EAAgBL,EAAhBK,qBAGA8G,EAAejH,EAAOK,KAAMP,iBAAhDE,EAAOK,qBAEDH,EAAWF,EAAO7C,GAAI,CAC1BkI,OAAQ,MACRC,KAAMmC,KAAKC,wBACGvH,GACTH,EAAOK,yCAIP,CAAEA,KAAML,EAAOK,2GChBlByH,EAAe,SAAAhI,sDAAU,WAAOC,EAAYC,gGACxCE,EAAeJ,EAAfI,oBAEFA,EAAWF,EAAO7C,GAAI,CAC1BkI,OAAQ,2CAGH,CAAEhF,KAAM,CAAElD,GAAI6C,EAAO7C,gICDR,SAAA4B,UACpB3B,gBAAC2K,qBAAoBhJ,GAAOI,OAAQ,SAAAb,UAASA,GAASA,EAAM0J,QAAQ,IAAK,KAAKA,QAAQ,IAAK,iEC6D7D,gBAC9BpK,IAAAA,SACAqK,IAAAA,eACAC,IAAAA,WACAC,IAAAA,YACAC,IAAAA,eACGtL,iFAEKuD,EAASgI,oBAAkB,CACjCvE,KAAM,UACN9E,SAAUiJ,EACVK,QAAS,KAHHjI,YAONjD,gCACGiD,MAAAA,SAAAA,EAAMpD,KAAI,SAACoD,EAAMkI,OACZ1K,EAAS,UACbA,EAAOuK,GAAkB/H,EAAKlD,GAE5BC,gCACG+K,GAAeA,SAAiBrL,OAAY0L,MAAOnI,KACpDjD,gBAACO,OAAkBb,GAAYe,OAAQA,EAAQ4K,MAAOpI,EAAK6H,KACxDtK,4BCxFI,gBAAGhB,IAAAA,OAAQC,IAAAA,OAAWC,iCAEjB,iBAAXF,IAAqBA,OAAYC,EAASD,IAC9CQ,gBAACsL,gBAAa9L,OAAQA,EAAQC,OAAQA,GAAYC,iHCHpC,SAAAiC,OACfC,EAAWC,qBAAmB,WAElC7B,gBAACuL,sBACK5J,GACJC,SAAUA,EACVG,OAAQ,SAAAb,UAEDA,GAEDS,EAAMI,SAAQb,EAAQS,EAAMI,OAAOb,IAEf,WAAjBb,EAAOa,GAAqBA,EAAMnB,IAAMmB,EAAM,OAASA,GAJ3CA,qCfQG,SAAAS,OACpB6J,EAA8C7J,EAA9C6J,iBAA+B9L,GAAeiC,EAA5BnB,WAA4BmB,oCAChD8J,EAAkBxJ,IAClByJ,EAAkBnJ,WAGtBvC,gBAAC2L,aAAejM,EACdM,gBAAC4L,sBAAmBC,QAAS,CAAE1J,KAAMsJ,EAAgBtJ,OAClDnC,EAAMuB,SAAS1B,IAAI8B,EAAMnB,UAAU,SAACgB,EAAO1B,UACnCE,EAAMyB,aAAaD,EAAO,CAC/BsK,UAAWL,EAAgBpJ,WAG/BrC,gBAAC+L,aAAUD,UAAWJ,EAAgBlJ,KAAM/C,OAAO,OAAOuM,aAAcR,4EgBzB3D,SAAA9I,UAGdA,EAAOK,cAAcL,EAAOK,YAAcqB,OAAO6H,YAAYvJ,EAAOsB,WAAWnE,KAAI,SAAA8I,SAAK,CAACA,EAAE7C,OAAQ6C,EAAE5C,UACrGrD,EAAO6F,wBAAwB7F,EAAO6F,uBAAwB,GAE5D,CACL2D,QAAS5F,EAAc5D,GACvB+F,OAAQhG,EAAaC,GACrByJ,QAAS7D,EAAc5F,GACvB0J,iBAAkB,iBAAc,IAAItC,MAAM,4CAC1CuC,OAAQpC,EAAavH,GACrB4J,OAAQ7B,EAAa/H,GACrB6J,WAAY,iBAAc,IAAIzC,MAAM,6CAC5BY,EAAahI,GACrB8J,WAAY,iBAAc,IAAI1C,MAAM,2DCpBrB,SAAC/D,OAAK0G,yDAAU,UAC5BA,EAAQzD,UAASyD,EAAQzD,QAAU,IAAIC,SAEpCwD,EAAQxE,YACT,WACA,YACA,MACEwE,EAAQzD,QAAQ0D,IAAI,WAAWD,EAAQzD,QAAQmB,IAAI,SAAU,uBAC7DsC,EAAQzD,QAAQ0D,IAAI,iBAAiBD,EAAQzD,QAAQmB,IAAI,eAAgB,iCAG3E,mBAGA,cAEEsC,EAAQzD,QAAQ0D,IAAI,WAAWD,EAAQzD,QAAQmB,IAAI,SAAU,2BAIhEwC,EAAQC,aAAaC,QAAQ,gBAC/BF,GAAOF,EAAQzD,QAAQmB,IAAI,iCAA2BwC,IAEnDG,aAAWC,UAAUhH,EAAK0G"}