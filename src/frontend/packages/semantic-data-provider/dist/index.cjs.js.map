{"version":3,"file":"index.cjs.js","sources":["../src/fields/ReferenceArrayField.js","../src/fields/ReferenceField.js","../src/dataHandling/FilterHandler.js","../src/inputs/ReferenceArrayInput.js","../src/inputs/ReificationArrayInput.js","../src/dataProvider/utils/getServerKeyFromUri.js","../src/dataProvider/methods/getOne.js","../src/dataProvider/utils/dereference.js","../src/dataProvider/utils/buildSparqlQuery.js","../src/dataProvider/utils/getRdfPrefixes.js","../node_modules/url-join/lib/url-join.js","../src/dataProvider/utils/findContainersWithTypes.js","../src/dataProvider/utils/getEmbedFrame.js","../src/dataProvider/methods/getList.js","../src/dataProvider/methods/getMany.js","../src/dataProvider/methods/getManyReference.js","../src/dataProvider/utils/uploadAllFiles.js","../src/dataProvider/methods/create.js","../src/dataProvider/methods/update.js","../src/dataProvider/methods/delete.js","../src/dataProvider/methods/deleteMany.js","../node_modules/jwt-decode/build/jwt-decode.esm.js","../src/dataProvider/utils/fetchPodConfig.js","../src/dataProvider/utils/fetchVoidEndpoints.js","../src/inputs/DateTimeInput.js","../src/dataHandling/GroupedReferenceHandler.js","../src/fields/ImageField.js","../src/inputs/ReferenceInput.js","../src/dataProvider/dataProvider.js","../src/httpClient.js"],"sourcesContent":["import React from 'react';\nimport { ReferenceArrayField as RaReferenceArrayField } from 'react-admin';\n\nconst ReferenceArrayField = ({ record, source, ...otherProps }) => {\n  if (record?.[source]) {\n    if (!Array.isArray(record[source])) {\n      record[source] = [record[source]];\n    }\n    record[source] = record[source].map(i => i['@id'] || i.id || i);\n  }\n  return <RaReferenceArrayField record={record} source={source} {...otherProps} />;\n};\n\nReferenceArrayField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceArrayField;\n","import React from 'react';\nimport { ReferenceField as RaReferenceField } from 'react-admin';\n\nconst ReferenceField = ({ record, source, ...otherProps }) => {\n  if (record[source]) {\n    if (typeof record[source] === 'object') {\n      record[source] = record[source]['@id'] || record[source].id;\n    }\n  }\n  return <RaReferenceField record={record} source={source} {...otherProps} />;\n};\n\nReferenceField.defaultProps = {\n  addLabel: true\n};\n\nexport default ReferenceField;\n","import React, { useState, useEffect } from 'react';\n\n/**\n * @example\n * <Show>\n *   <FilterHandler\n *     source=\"property\" // ex pair:organizationOfMembership\n *     filter={{\n *       'propertyToFilter':'value'\n *     }} // ex {{'pair:membershipRole':'http://localhost:3000/membership-roles/role-1'}}\n *     >\n *     <SingleFieldList>\n *    </SingleFieldList>\n *   </FilterHandler>\n * </Show>\n */\n\nconst FilterHandler = ({ children, record, filter, source, ...otherProps }) => {\n  const [filtered, setFiltered] = useState();\n  useEffect(() => {\n    if (record && source && Array.isArray(record?.[source])) {\n      const filteredData = record?.[source].filter(r => {\n        let eq = true;\n        for (const key in filter) {\n          const value = r[key];\n          if (Array.isArray(value)) {\n            if (!value.includes(filter[key])) {\n              eq = false;\n            }\n          } else {\n            if (value !== filter[key]) {\n              eq = false;\n            }\n          }\n        }\n        return eq;\n      });\n      let newRecord = {\n        ...record\n      };\n      //undefined setted if no data to obtain no render in RightLabel or equivalent\n      newRecord[source] = filteredData.length > 0 ? filteredData : undefined;\n      setFiltered(newRecord);\n    }\n  }, [record, source, filter]);\n\n  return (\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          ...otherProps,\n          record: filtered,\n          addLabel: true,\n          source\n        });\n      })}\n    </>\n  );\n};\nexport default FilterHandler;\n","import React from 'react';\nimport { ReferenceArrayInput as RaReferenceArrayInput, useResourceContext } from 'react-admin';\n\nconst ReferenceArrayInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceArrayInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // if the linked field value is not an array, turns it into an array.\n        // Necessary as JSON-LD are sometimes arrays, sometimes not (when there is one value)\n        // and the ReferenceArrayInput component only accept arrays\n        if (!Array.isArray(value)) value = [value];\n        // If a format prop was defined, apply it to the array\n        if (props.format) value = props.format(value);\n        // If the values are objects with @id field, turn it to a simple string\n        return value.map(v => (typeof v === 'object' ? v.id || v['@id'] : v));\n      }}\n    />\n  );\n};\n\nexport default ReferenceArrayInput;\n","import React, { useEffect, useState } from 'react';\nimport { ArrayInput, SimpleFormIterator, TextInput } from 'react-admin';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useReferenceInputStyles = makeStyles({\n  form: {\n    display: 'flex'\n  },\n  input: {\n    paddingRight: '20px'\n  }\n});\n\nconst useHideInputStyles = makeStyles({\n  root: {\n    display: 'none'\n  }\n});\n\nconst ReificationArrayInput = props => {\n  const { reificationClass, children, ...otherProps } = props;\n  const flexFormClasses = useReferenceInputStyles();\n  const hideInputStyles = useHideInputStyles();\n\n  return (\n    <ArrayInput {...otherProps}>\n      <SimpleFormIterator classes={{ form: flexFormClasses.form }}>\n        {React.Children.map(props.children, (child, i) => {\n          return React.cloneElement(child, {\n            className: flexFormClasses.input\n          });\n        })}\n        <TextInput className={hideInputStyles.root} source=\"type\" initialValue={reificationClass} />\n      </SimpleFormIterator>\n    </ArrayInput>\n  );\n};\n\nexport default ReificationArrayInput;\n","// Return the first server matching with the baseUrl\nconst getServerKeyFromUri = (uri, dataServers) => {\n  return Object.keys(dataServers).find(key => {\n    console.log('get server key', uri, dataServers[key])\n    return uri.startsWith(dataServers[key].baseUrl)\n  });\n};\n\nexport default getServerKeyFromUri;\n","import jsonld from 'jsonld';\nimport getServerKeyFromUri from \"../utils/getServerKeyFromUri\";\n\nconst getOneMethod = config => async (resourceId, params) => {\n  const { dataServers, resources, httpClient, jsonContext } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const serverKey = getServerKeyFromUri(params.id, dataServers);\n\n  let { json: data } = await httpClient(params.id, {\n    noToken: !serverKey || dataServers[serverKey].authServer !== true\n  });\n  data.id = data.id || data['@id'];\n\n  // We compact only if the context is different between the frontend and the middleware\n  // TODO deep compare if the context is an object\n  if (data['@context'] !== jsonContext) {\n    data = await jsonld.compact(data, jsonContext);\n  }\n\n  // Transform single value into array if forceArray is set\n  if (dataModel.list?.forceArray) {\n    for (const forceArrayItem of dataModel.list?.forceArray) {\n      if (data[forceArrayItem] && !Array.isArray(data[forceArrayItem])) {\n        data[forceArrayItem] = [data[forceArrayItem]];\n      }\n    }\n  }\n\n  return { data: data };\n};\n\nexport default getOneMethod;\n","// Return an object in the form of predicate => parentPredicate\nconst flattenPredicate = (accumulator, predicate, parent = 'root') => {\n  if (predicate.includes('/')) {\n    const matches = predicate.split(/\\/(.+)/);\n    accumulator[matches[0]] = parent;\n    flattenPredicate(accumulator, matches[1], matches[0]);\n  } else {\n    accumulator[predicate] = parent;\n  }\n  return accumulator;\n};\n\n// Transform ontology:predicate to OntologyPredicate in order to use it as a variable name\nconst generateSparqlVarName = predicate =>\n  predicate\n    .split(':')\n    .map(s => s[0].toUpperCase() + s.slice(1))\n    .join('');\n\nexport const buildDereferenceQuery = predicates => {\n  let queries = [];\n\n  if (predicates) {\n    const flattenedPredicates = predicates.reduce((acc, predicate) => flattenPredicate(acc, predicate), {});\n\n    for (const [predicate, parent] of Object.entries(flattenedPredicates)) {\n      const varName = generateSparqlVarName(predicate);\n      const parentVarName = parent === 'root' ? '1' : generateSparqlVarName(parent);\n\n      // Group queries by parent, so that we can group WHERE triples in the same OPTIONAL tag\n      const groupKey = parent === 'root' ? predicate : parent;\n      if (!queries[groupKey]) queries[groupKey] = [];\n\n      queries[groupKey].push(`\n        ?s${parentVarName} ${predicate} ?s${varName} .\n        ?s${varName} ?p${varName} ?o${varName} .\n      `);\n    }\n  }\n\n  return {\n    construct: Object.values(queries)\n      .map(groupedQueries => Object.values(groupedQueries).join('\\n'))\n      .join('\\n'),\n    where: Object.values(queries)\n      .map(groupedQueries => `OPTIONAL { ${Object.values(groupedQueries).join('\\n')} }`)\n      .join('\\n')\n  };\n};\n","import { buildDereferenceQuery } from './dereference';\nimport getRdfPrefixes from './getRdfPrefixes';\n\nconst buildSparqlQuery = ({ containers, params: { filter }, dereference, ontologies }) => {\n  let whereQuery = '';\n\n  if (filter) {\n    if (filter.q && filter.q.length > 0) {\n      whereQuery += `\n      {\n        SELECT ?s1\n        WHERE {\n          ?s1 ?p1 ?o1 .\n          FILTER regex(lcase(str(?o1)), \"${filter.q.toLowerCase()}\")\n          FILTER NOT EXISTS {?s1 a ?o1}\n        }\n      }\n      `;\n      delete filter.q;\n    }\n    Object.keys(filter).forEach(predicate => {\n      if (filter[predicate]) {\n        const object = filter[predicate].startsWith('http') ? `<${filter[predicate]}>` : filter[predicate];\n        whereQuery += `?s1 ${predicate} ${object} .`;\n      }\n    });\n  }\n\n  const dereferenceQuery = buildDereferenceQuery(dereference);\n\n  return `\n    ${getRdfPrefixes(ontologies)}\n    CONSTRUCT {\n      ?s1 ?p2 ?o2 .\n      ${dereferenceQuery.construct}\n    }\n    WHERE {\n      ?containerUri ldp:contains ?s1 .\n      FILTER( ?containerUri IN (${containers.map(container => `<${container}>`).join(', ')}) ) .\n      FILTER( (isIRI(?s1)) ) .\n      ${whereQuery}\n      ${dereferenceQuery.where}\n      ?s1 ?p2 ?o2 .\n    }\n  `;\n};\n\nexport default buildSparqlQuery;\n","const getRdfPrefixes = ontologies => {\n  return ontologies.map(ontology => `PREFIX ${ontology.prefix}: <${ontology.url}>`).join('\\n');\n};\n\nexport default getRdfPrefixes;\n","(function (name, context, definition) {\n  if (typeof module !== 'undefined' && module.exports) module.exports = definition();\n  else if (typeof define === 'function' && define.amd) define(definition);\n  else context[name] = definition();\n})('urljoin', this, function () {\n\n  function normalize (strArray) {\n    var resultArray = [];\n    if (strArray.length === 0) { return ''; }\n\n    if (typeof strArray[0] !== 'string') {\n      throw new TypeError('Url must be a string. Received ' + strArray[0]);\n    }\n\n    // If the first part is a plain protocol, we combine it with the next part.\n    if (strArray[0].match(/^[^/:]+:\\/*$/) && strArray.length > 1) {\n      var first = strArray.shift();\n      strArray[0] = first + strArray[0];\n    }\n\n    // There must be two or three slashes in the file protocol, two slashes in anything else.\n    if (strArray[0].match(/^file:\\/\\/\\//)) {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1:///');\n    } else {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1://');\n    }\n\n    for (var i = 0; i < strArray.length; i++) {\n      var component = strArray[i];\n\n      if (typeof component !== 'string') {\n        throw new TypeError('Url must be a string. Received ' + component);\n      }\n\n      if (component === '') { continue; }\n\n      if (i > 0) {\n        // Removing the starting slashes for each component but the first.\n        component = component.replace(/^[\\/]+/, '');\n      }\n      if (i < strArray.length - 1) {\n        // Removing the ending slashes for each component but the last.\n        component = component.replace(/[\\/]+$/, '');\n      } else {\n        // For the last component we will combine multiple slashes to a single one.\n        component = component.replace(/[\\/]+$/, '/');\n      }\n\n      resultArray.push(component);\n\n    }\n\n    var str = resultArray.join('/');\n    // Each input component is now separated by a single slash except the possible first plain protocol part.\n\n    // remove trailing slash before parameters or hash\n    str = str.replace(/\\/(\\?|&|#[^!])/g, '$1');\n\n    // replace ? in parameters with &\n    var parts = str.split('?');\n    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');\n\n    return str;\n  }\n\n  return function () {\n    var input;\n\n    if (typeof arguments[0] === 'object') {\n      input = arguments[0];\n    } else {\n      input = [].slice.call(arguments);\n    }\n\n    return normalize(input);\n  };\n\n});\n","import urlJoin from \"url-join\";\n\nconst findContainersWithTypes = (types, servers, dataServers) => {\n  let containers = {};\n  let existingContainers = [];\n  Object.keys(dataServers).forEach(key1 => {\n    Object.keys(dataServers[key1].containers).forEach(key2 => {\n      if( !servers || (Array.isArray(servers) ? servers.includes(key2) : servers === key2)) {\n        Object.keys(dataServers[key1].containers[key2]).forEach(type => {\n          if( types.includes(type) ) {\n            dataServers[key1].containers[key2][type].map(path => {\n              const containerUri = urlJoin(dataServers[key2].baseUrl, path);\n\n              // Avoid returning the same container several times\n              if( !existingContainers.includes(containerUri) ) {\n                existingContainers.push(containerUri);\n\n                if( !containers[key1] ) containers[key1] = [];\n                containers[key1].push(containerUri);\n              }\n            })\n          }\n        });\n      }\n    });\n  })\n  return containers;\n}\n\nexport default findContainersWithTypes;\n","const getEmbedFrame = paths => {\n  let embedFrame = {},\n    predicates;\n  if (paths) {\n    for (let path of paths) {\n      if (path.includes('/')) {\n        predicates = path.split('/').reverse();\n      } else {\n        predicates = [path];\n      }\n      embedFrame = {\n        ...embedFrame,\n        ...predicates.reduce(\n          (accumulator, predicate) => ({\n            [predicate]: {\n              '@embed': '@last',\n              ...accumulator\n            }\n          }),\n          {}\n        )\n      };\n    }\n    return embedFrame;\n  }\n};\n\nexport default getEmbedFrame;\n","import buildSparqlQuery from '../utils/buildSparqlQuery';\nimport findContainersWithTypes from \"../utils/findContainersWithTypes\";\nimport getEmbedFrame from '../utils/getEmbedFrame';\nimport jsonld from 'jsonld';\n\nexport const isType = (type, resource) => {\n  const resourceType = resource.type || resource['@type'];\n  return Array.isArray(resourceType) ? resourceType.includes(type) : resourceType === type;\n};\n\nconst getListMethod = config => async (resourceId, params) => {\n  let { dataServers, httpClient, resources, ontologies, jsonContext } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  let containers;\n  if( dataModel.list?.containers && dataModel.list?.containers.length > 0 ) {\n    // If containers are set explicitly, use them\n    containers = dataModel.list?.containers;\n  } else {\n    containers = findContainersWithTypes(dataModel.types, dataModel.list?.servers, dataServers);\n  }\n\n  const frame = {\n    '@context': jsonContext,\n    '@type': dataModel.types,\n    // Embed only what we explicitly asked to dereference\n    // Otherwise we may have same-type resources embedded in other resources\n    '@embed': '@never',\n    ...getEmbedFrame(dataModel.list?.dereference)\n  };\n\n  const sparqlQueryPromises = Object.keys(containers).map(serverKey =>\n    new Promise((resolve, reject) => {\n      const sparqlQuery = buildSparqlQuery({\n        containers: containers[serverKey],\n        params: { ...params, filter: { ...dataModel.list?.filter, ...params.filter } },\n        dereference: dataModel.dereference,\n        ontologies\n      });\n\n      httpClient(dataServers[serverKey].sparqlEndpoint, {\n          method: 'POST',\n          body: sparqlQuery,\n          noToken: dataServers[serverKey].authServer !== true\n        })\n        .then(({ json }) => {\n          // omitGraph option force results to be in a @graph, even if we have a single result\n          return jsonld.frame(json, frame, { omitGraph: false });\n        })\n        .then(compactJson => {\n          resolve(compactJson['@graph'] || []);\n        })\n        .catch(e => reject(e));\n    })\n  );\n\n  // Run simultaneous SPARQL queries\n  let results = await Promise.all(sparqlQueryPromises);\n\n  // Merge all results in one array\n  results = [].concat.apply(...results);\n\n  if (results.length === 0) {\n    return { data: [], total: 0 };\n  } else {\n    // Add id in addition to @id, as this is what React-Admin expects\n    let returnData = results.map(item => {\n      item.id = item.id || item['@id'];\n      return item;\n    });\n\n    if (params.sort) {\n      returnData = returnData.sort((a, b) => {\n        if (a[params.sort.field] && b[params.sort.field]) {\n          if (params.sort.order === 'ASC') {\n            return a[params.sort.field].localeCompare(b[params.sort.field]);\n          } else {\n            return b[params.sort.field].localeCompare(a[params.sort.field]);\n          }\n        } else {\n          return true;\n        }\n      });\n    }\n    if (params.pagination) {\n      returnData = returnData.slice(\n        (params.pagination.page - 1) * params.pagination.perPage,\n        params.pagination.page * params.pagination.perPage\n      );\n    }\n\n    return {data: returnData, total: results.length};\n  }\n\n\n  // if (!resources[resourceId]) Error(`Resource ${resourceId} is not mapped in resources file`);\n  //\n  // if (params.id || params['@id'] || resources[resourceId].fetchContainer) {\n  //   const url = params.id || params['@id'] || resources[resourceId].containerUri;\n  //   let { json } = await httpClient(url);\n  //\n  //   if (isType('ldp:Container', json)) {\n  //     /*\n  //      * LDP Container\n  //      */\n  //     let returnData = json['ldp:contains'].map(item => {\n  //       item.id = item.id || item['@id'];\n  //       return item;\n  //     });\n  //\n  //     // Apply filter to results\n  //     if (params.filter) {\n  //       // Remove search params from filter\n  //       if (params.filter.q) {\n  //         delete params.filter.q;\n  //       }\n  //       if (Object.keys(params.filter).length > 0) {\n  //         returnData = returnData.filter(resource =>\n  //           Object.entries(params.filter).some(([k, v]) =>\n  //             Array.isArray(resource[k]) ? resource[k].includes(v) : resource[k] === v\n  //           )\n  //         );\n  //       }\n  //     }\n  //\n  //     if (params.sort) {\n  //       returnData = returnData.sort((a, b) => {\n  //         if (a[params.sort.field] && b[params.sort.field]) {\n  //           if (params.sort.order === 'ASC') {\n  //             return a[params.sort.field].localeCompare(b[params.sort.field]);\n  //           } else {\n  //             return b[params.sort.field].localeCompare(a[params.sort.field]);\n  //           }\n  //         } else {\n  //           return true;\n  //         }\n  //       });\n  //     }\n  //     if (params.pagination) {\n  //       returnData = returnData.slice(\n  //         (params.pagination.page - 1) * params.pagination.perPage,\n  //         params.pagination.page * params.pagination.perPage\n  //       );\n  //     }\n  //\n  //     return { data: returnData, total: json['ldp:contains'].length };\n  //   } else {\n  //     /*\n  //      * ActivityPub collection\n  //      */\n  //\n  //     // If the collection is split amongst several pages, get the first page\n  //     if (json.first) {\n  //       const result = await httpClient(json.first);\n  //       json = result.json;\n  //     }\n  //\n  //     const listProperty = ['as:orderedItems', 'orderedItems', 'as:items', 'items'].find(p => json[p]);\n  //     if (!listProperty) return { data: [], total: 0 };\n  //\n  //     // TODO fetch several pages depending on params.pagination\n  //\n  //     let returnData = json[listProperty].map(item => {\n  //       item.id = item.id || item['@id'];\n  //       return item;\n  //     });\n  //\n  //     return { data: returnData, total: json.totalItems };\n  //   }\n  // } else {\n  //   const sparqlQuery = buildSparqlQuery({\n  //     types: resources[resourceId].types,\n  //     params: { ...params, filter: { ...resources[resourceId].filter, ...params.filter } },\n  //     dereference: resources[resourceId].dereference,\n  //     ontologies\n  //   });\n  //\n  //   const { json } = await httpClient(sparqlEndpoint, {\n  //     method: 'POST',\n  //     body: sparqlQuery\n  //   });\n  //\n  //   const frame = {\n  //     '@context': jsonContext,\n  //     '@type': resources[resourceId].types,\n  //     // Embed only what we explicitly asked to dereference\n  //     // Otherwise we may have same-type resources embedded in other resources\n  //     '@embed': '@never',\n  //     ...getEmbedFrame(resources[resourceId].dereference)\n  //   };\n  //\n  //   // omitGraph option force results to be in a @graph, even if we have a single result\n  //   const compactJson = await jsonld.frame(json, frame, { omitGraph: false });\n  //\n  //   if (Object.keys(compactJson).length === 1) {\n  //     // If we have only the context, it means there is no match\n  //     return { data: [], total: 0 };\n  //   } else {\n  //     // Add id in addition to @id, as this is what React-Admin expects\n  //     let returnData = compactJson['@graph'].map(item => {\n  //       item.id = item.id || item['@id'];\n  //       return item;\n  //     });\n  //\n  //     if (params.sort) {\n  //       returnData = returnData.sort((a, b) => {\n  //         if (a[params.sort.field] && b[params.sort.field]) {\n  //           if (params.sort.order === 'ASC') {\n  //             return a[params.sort.field].localeCompare(b[params.sort.field]);\n  //           } else {\n  //             return b[params.sort.field].localeCompare(a[params.sort.field]);\n  //           }\n  //         } else {\n  //           return true;\n  //         }\n  //       });\n  //     }\n  //     if (params.pagination) {\n  //       returnData = returnData.slice(\n  //         (params.pagination.page - 1) * params.pagination.perPage,\n  //         params.pagination.page * params.pagination.perPage\n  //       );\n  //     }\n  //\n  //     return { data: returnData, total: compactJson['@graph'].length };\n  //   }\n\n    // OTHER METHOD: FETCH ONLY RESOURCES URIs AND FETCH THEM INDEPENDENTLY\n    // TODO compare the performance of the two methods, and eventually allow both of them\n    //\n    // const sparqlQuery = buildSparqlUriQuery({\n    //   types: resources[resourceId].types,\n    //   params: { ...params, filter: { ...resources[resourceId].filter, ...params.filter } },\n    //   ontologies\n    // });\n    //\n    // let { json } = await httpClient(sparqlEndpoint, {\n    //   method: 'POST',\n    //   body: sparqlQuery\n    // });\n    //\n    // const total = json.length;\n    //\n    // if (params.pagination) {\n    //   json = json.slice(\n    //     (params.pagination.page - 1) * params.pagination.perPage,\n    //     params.pagination.page * params.pagination.perPage\n    //   );\n    // }\n    //\n    // let data = await Promise.allSettled(\n    //   json.map(result => httpClient(result.resource.value).then(result => result.json))\n    // );\n    //\n    // // Ignore resources we were not able to fetch\n    // data = data.filter(r => r.status === 'fulfilled').map(r => r.value);\n    //\n    // return { data, total };\n  // }\n};\n\nexport default getListMethod;\n","import getOne from './getOne';\n\nconst getManyMethod = config => async (resourceId, params) => {\n  const { returnFailedResources } = config;\n\n  let returnData = [];\n\n  for (let id of params.ids) {\n    id = typeof id === 'object' ? id['@id'] : id;\n\n    try {\n      const data = await getOne(config)(resourceId, { id });\n      returnData.push(data);\n    } catch (e) {\n      // Catch if one resource fails to load\n      // Otherwise no references will be show if only one is missing\n      // See https://github.com/marmelab/react-admin/issues/5190\n      if (returnFailedResources) {\n        // Return only the ID of the resource\n        returnData.push({ id });\n      } else {\n        // Do nothing. The resource will not appear in the results.\n      }\n    }\n  }\n\n  return { data: returnData };\n};\n\nexport default getManyMethod;\n","import getList from './getList';\n\nconst getManyReferenceMethod = config => async (resourceId, params) => {\n  params.filter = { ...params.filter, [params.target]: params.id };\n  return await getList(config)(params);\n};\n\nexport default getManyReferenceMethod;\n","import createSlug from 'speakingurl';\n\nexport const getSlugWithExtension = fileName => {\n  let fileExtension = '';\n  let splitFileName = fileName.split('.');\n  if (splitFileName.length > 1) {\n    fileExtension = splitFileName.pop();\n    fileName = splitFileName.join('.');\n  }\n  return createSlug(fileName, { lang: 'fr' }) + '.' + fileExtension;\n};\n\nexport const isFile = o => o && o.rawFile && o.rawFile instanceof File;\n\nconst uploadFile = async (rawFile, config) => {\n  const response = await config.httpClient(config.uploadsContainerUri, {\n    method: 'POST',\n    body: rawFile,\n    headers: new Headers({\n      // We must sluggify the file name, because we can't use non-ASCII characters in the header\n      // However we keep the extension apart (if it exists) so that it is not replaced with a -\n      // TODO let the middleware guess the extension based on the content type\n      Slug: getSlugWithExtension(rawFile.name),\n      'Content-Type': rawFile.type\n    })\n  });\n\n  if (response.status === 201) {\n    return response.headers.get('Location');\n  }\n};\n\n/*\n * Look for raw files in the record data.\n * If there are any, upload them and replace the file by its URL.\n */\nconst uploadAllFiles = async (record, config) => {\n  if (!config.uploadsContainerUri) throw new Error('No uploadsContainerUri defined for the data provider');\n\n  for (let property in record) {\n    if (record.hasOwnProperty(property)) {\n      if (Array.isArray(record[property])) {\n        for (let i = 0; i < record[property].length; i++) {\n          if (isFile(record[property][i])) {\n            record[property][i] = await uploadFile(record[property][i].rawFile, config);\n          }\n        }\n      } else {\n        if (isFile(record[property])) {\n          record[property] = await uploadFile(record[property].rawFile, config);\n        }\n      }\n    }\n  }\n  return record;\n};\n\nexport default uploadAllFiles;\n","import uploadAllFiles from '../utils/uploadAllFiles';\nimport getOne from './getOne';\nimport findContainersWithTypes from \"../utils/findContainersWithTypes\";\nimport getServerKeyFromUri from \"../utils/getServerKeyFromUri\";\n\nconst createMethod = config => async (resourceId, params) => {\n  const { dataServers, resources, httpClient, jsonContext } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const headers = new Headers();\n\n  if (dataModel.fieldsMapping?.title) {\n    headers.set(\n      'Slug',\n      params.data[dataModel.fieldsMapping?.title]\n    );\n  }\n\n  let containerUri, serverKey;\n  if( dataModel.create?.container ) {\n    containerUri = dataModel.create?.container;\n    serverKey = getServerKeyFromUri(containerUri, dataServers);\n  } else {\n    serverKey = dataModel.create?.server || Object.keys(config.dataServers).find(key => config.dataServers[key].default === true);\n    if( !serverKey ) throw new Error(\"You must define a server for the creation, or a container, or a default server\");\n\n    const containers = findContainersWithTypes(dataModel.types, [serverKey], dataServers);\n    // Extract the containerUri from the results (and ensure there is only one)\n    const serverKeys = Object.keys(containers);\n\n    if( !serverKeys || serverKeys.length === 0 ) throw new Error(`No container with types ${JSON.stringify(dataModel.types)} found on server ${serverKey}`)\n    if( serverKeys.length > 1 || containers[serverKeys[0]].length > 1 ) throw new Error(`More than one container detected with types ${JSON.stringify(dataModel.types)} on server ${serverKey}`);\n    containerUri = containers[serverKeys[0]][0];\n  }\n\n  // Upload files, if there are any\n  // params.data = await uploadAllFiles(params.data, config);\n\n  const { headers: responseHeaders } = await httpClient(containerUri, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n      '@context': jsonContext,\n      '@type': dataModel.types,\n      ...params.data\n    }),\n    noToken: dataServers[serverKey].authServer !== true\n  });\n\n  // Retrieve newly-created resource\n  const resourceUri = responseHeaders.get('Location');\n  return await getOne(config)(resourceId, { id: resourceUri });\n};\n\nexport default createMethod;\n","import uploadAllFiles from '../utils/uploadAllFiles';\n\nconst updateMethod = config => async (resourceId, params) => {\n  const { httpClient, jsonContext } = config;\n\n  // Upload files, if there are any\n  params.data = await uploadAllFiles(params.data, config);\n\n  await httpClient(params.id, {\n    method: 'PUT',\n    body: JSON.stringify({\n      '@context': jsonContext,\n      ...params.data\n    })\n  });\n\n  return { data: params.data };\n};\n\nexport default updateMethod;\n","const deleteMethod = config => async (resourceId, params) => {\n  const { httpClient } = config;\n\n  await httpClient(params.id, {\n    method: 'DELETE'\n  });\n\n  return { data: { id: params.id } };\n};\n\nexport default deleteMethod;\n","const deleteManyMethod = config => async (resourceId, params) => {\n  const { httpClient } = config;\n  let ids = [];\n\n  for (let id of params.ids) {\n    try {\n      await httpClient(id, {\n        method: 'DELETE'\n      });\n      ids.push(id);\n    } catch (e) {\n      // Do nothing if we fail to delete a resource\n    }\n  }\n\n  return { data: ids };\n};\n\nexport default deleteManyMethod;\n","function e(e){this.message=e}e.prototype=new Error,e.prototype.name=\"InvalidCharacterError\";var r=\"undefined\"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,\"\");if(t.length%4==1)throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var n,o,a=0,i=0,c=\"\";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);return c};function t(e){var t=e.replace(/-/g,\"+\").replace(/_/g,\"/\");switch(t.length%4){case 0:break;case 2:t+=\"==\";break;case 3:t+=\"=\";break;default:throw\"Illegal base64url string!\"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t=\"0\"+t),\"%\"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if(\"string\"!=typeof e)throw new n(\"Invalid token specified\");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(\".\")[o]))}catch(e){throw new n(\"Invalid token specified: \"+e.message)}}n.prototype=new Error,n.prototype.name=\"InvalidTokenError\";export default o;export{n as InvalidTokenError};\n//# sourceMappingURL=jwt-decode.esm.js.map\n","import jwtDecode from 'jwt-decode';\n\nconst getContainerFromUri = str => str.match(new RegExp(`(.*)/.*`))[1];\n\nconst fetchPodConfig = async config => {\n  const podKey = Object.keys(config.dataServers).find(key => config.dataServers[key].pod === true);\n\n  // If we have a POD in our server\n  if( podKey ) {\n    const token = localStorage.getItem('token');\n\n    // If the user is logged in\n    if (token) {\n      const { webId } = jwtDecode(token);\n\n      // TODO find POD URI and SPARQL endpoint from user profile\n      const podUri = getContainerFromUri(webId);\n\n      // Fill the config provided to the data provider\n      config.dataServers[podKey].name = 'My Pod';\n      config.dataServers[podKey].baseUrl = podUri;\n      config.dataServers[podKey].sparqlEndpoint = podUri + '/sparql';\n    }\n  }\n}\n\nexport default fetchPodConfig;\n","const fetchVoidEndpoints = async config => {\n  const fetchPromises = Object.values(config.dataServers)\n    .filter(server => server.pod !== true)\n    .map(server =>\n      config.httpClient(new URL('/.well-known/void', server.baseUrl))\n        .then(result => ({ data: result.json }))\n        .catch(e => { if( e.status === 404 ) { return({ error: e }) } else { throw e }})\n    );\n\n  const results = await Promise.all(fetchPromises);\n\n  for( let result of results ) {\n    // Ignore unfetchable endpoints\n    if( result.data ) {\n      // TODO modify config.dataServers based on the VOID configs returned\n    }\n  }\n}\n\nexport default fetchVoidEndpoints;\n","import React from 'react';\nimport { DateTimeInput as RaDateTimeInput } from 'react-admin';\n\n/**\n * @deprecated Use the component from the @semapps/date-components instead\n */\nconst DateTimeInput = props => (\n  <RaDateTimeInput {...props} format={value => value && value.replace(' ', 'T').replace('Z', '')} />\n);\n\nexport default DateTimeInput;\n","import React from 'react';\nimport { useQueryWithStore } from 'react-admin';\nimport { default as FilterHandler } from './FilterHandler';\n\n/*\n * @example Label used in examples\n *  const Label = ({label, ...otherProps})=>{\n *     return <h2>{label}</h2>\n *  }\n *\n * @example show header for each group with group property thanks to groupHeader\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupHeader={({group,...otherProps}) => <Label {...otherProps} label={group['pair:label']}></Label> }\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example call chhildren with label thanks to groupLabel\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example conditional show of group if no data in source. Conditionale groupHeader is not possible because GroupedArrayField define group before filter ; need use chhildren.\n * const ConditionalSourceDefinedHandler = ({record,source,children,...otherProps})=>{\n *   if (record?.[source] && (!Array.isArray(record[source])||record[source].length>0)){\n *     return  React.Children.map(children, (child, i) => {\n *         return React.cloneElement(child, {...otherProps,record,source});\n *       })\n *   }else{\n *     return <></>\n *   }\n * }\n *\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n *   addLabel={false}\n * >\n *  <ConditionalSourceDefinedHandler>\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <GridList>\n *    </GridList>\n *   </ArrayField>\n *  </ConditionalSourceDefinedHandler>\n * </GroupedReferenceHandler>\n *\n *\n */\nconst GroupedReferenceHandler = ({\n  children,\n  groupReference,\n  groupLabel,\n  groupHeader,\n  filterProperty,\n  ...otherProps\n}) => {\n  const { data } = useQueryWithStore({\n    type: 'getList',\n    resource: groupReference,\n    payload: {}\n  });\n\n  return (\n    <>\n      {data?.map((data, index) => {\n        let filter = {};\n        filter[filterProperty] = data.id;\n        return (\n          <>\n            {groupHeader && groupHeader({ ...otherProps, group: data })}\n            <FilterHandler {...otherProps} filter={filter} label={data[groupLabel]}>\n              {children}\n            </FilterHandler>\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport default GroupedReferenceHandler;\n","import React from 'react';\nimport { ImageField as RaImageField } from 'react-admin';\n\nconst ImageField = ({ record, source, ...otherProps }) => {\n  // For the display, we need to have the URI in a src property\n  if (typeof record === 'string') record = { [source]: record };\n  return <RaImageField record={record} source={source} {...otherProps} />;\n};\n\nexport default ImageField;\n","import React from 'react';\nimport { ReferenceInput as RaReferenceInput, useResourceContext } from 'react-admin';\n\nconst ReferenceInput = props => {\n  const resource = useResourceContext({});\n  return (\n    <RaReferenceInput\n      {...props}\n      resource={resource}\n      format={value => {\n        // If there is no value, return immediately\n        if (!value) return value;\n        // If a format prop was defined, apply it\n        if (props.format) value = props.format(value);\n        // If the value is an object with an @id field, return the uri\n        return typeof value === 'object' ? value.id || value['@id'] : value;\n      }}\n    />\n  );\n};\n\nexport default ReferenceInput;\n","import getOneMethod from './methods/getOne';\nimport getListMethod from './methods/getList';\nimport getManyMethod from './methods/getMany';\nimport getManyReferenceMethod from './methods/getManyReference';\nimport createMethod from './methods/create';\nimport updateMethod from './methods/update';\nimport deleteMethod from './methods/delete';\nimport deleteManyMethod from './methods/deleteMany';\nimport fetchPodConfig from \"./utils/fetchPodConfig\";\nimport fetchVoidEndpoints from \"./utils/fetchVoidEndpoints\";\n\nconst dataProvider = config => {\n  // TODO verify all data provider config + data models\n\n  if (!config.jsonContext) config.jsonContext = Object.fromEntries(config.ontologies.map(o => [o.prefix, o.url]));\n  if (!config.returnFailedResources) config.returnFailedResources = false;\n\n  const fetchPodConfigPromise = fetchPodConfig(config);\n  const fetchVoidEndpointsPromise = fetchVoidEndpoints(config);\n\n  const waitForVoidEndpoints = method => async (...arg) => {\n    await fetchPodConfigPromise;\n    await fetchVoidEndpointsPromise; // Return immediately if promise is fulfilled\n    return await method(...arg);\n  };\n\n  return {\n    getList: waitForVoidEndpoints(getListMethod(config)),\n    getOne: waitForVoidEndpoints(getOneMethod(config)),\n    getMany: waitForVoidEndpoints(getManyMethod(config)),\n    getManyReference: waitForVoidEndpoints(getManyReferenceMethod(config)),\n    create: waitForVoidEndpoints(createMethod(config)),\n    update: waitForVoidEndpoints(updateMethod(config)),\n    updateMany: () => {\n      throw new Error('updateMany is not implemented yet');\n    },\n    delete: waitForVoidEndpoints(deleteMethod(config)),\n    deleteMany: waitForVoidEndpoints(deleteManyMethod(config))\n  };\n};\n\nexport default dataProvider;\n","import { fetchUtils } from 'react-admin';\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) options.headers = new Headers();\n\n  switch (options.method) {\n    case 'POST':\n    case 'PATCH':\n    case 'PUT':\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      if (!options.headers.has('Content-Type')) options.headers.set('Content-Type', 'application/ld+json');\n      break;\n\n    case 'DELETE':\n      break;\n\n    case 'GET':\n    default:\n      if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n      break;\n  }\n\n  if( !options.noToken ) {\n    const token = localStorage.getItem('token');\n    if (token) options.headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return fetchUtils.fetchJson(url, options);\n};\n\nexport default httpClient;\n"],"names":["ReferenceArrayField","record","source","otherProps","Array","isArray","map","i","id","React","RaReferenceArrayField","defaultProps","addLabel","ReferenceField","_typeof","RaReferenceField","FilterHandler","children","filter","useState","filtered","setFiltered","useEffect","filteredData","r","eq","key","value","includes","newRecord","length","undefined","Children","child","cloneElement","ReferenceArrayInput","props","resource","useResourceContext","RaReferenceArrayInput","format","v","useReferenceInputStyles","makeStyles","form","display","input","paddingRight","useHideInputStyles","root","getServerKeyFromUri","uri","dataServers","Object","keys","find","console","log","startsWith","baseUrl","getOneMethod","config","resourceId","params","resources","httpClient","jsonContext","dataModel","Error","serverKey","noToken","authServer","data","json","jsonld","compact","list","_dataModel$list","forceArray","_dataModel$list2","forceArrayItem","generateSparqlVarName","predicate","split","s","toUpperCase","slice","join","buildSparqlQuery","containers","dereference","ontologies","whereQuery","q","toLowerCase","forEach","object","dereferenceQuery","predicates","queries","flattenedPredicates","reduce","acc","flattenPredicate","accumulator","parent","matches","entries","varName","parentVarName","groupKey","push","construct","values","groupedQueries","where","buildDereferenceQuery","ontology","prefix","url","getRdfPrefixes","container","context","definition","this","normalize","strArray","resultArray","TypeError","match","first","shift","replace","component","str","parts","arguments","call","module","exports","findContainersWithTypes","types","servers","existingContainers","key1","key2","type","path","containerUri","urlJoin","getEmbedFrame","paths","embedFrame","reverse","getListMethod","_dataModel$list3","_dataModel$list4","frame","_dataModel$list5","sparqlQueryPromises","Promise","resolve","reject","sparqlQuery","_dataModel$list6","sparqlEndpoint","method","body","then","omitGraph","compactJson","e","all","results","concat","apply","total","returnData","item","sort","a","b","field","order","localeCompare","pagination","page","perPage","getManyMethod","returnFailedResources","ids","getOne","getManyReferenceMethod","target","getList","isFile","o","rawFile","File","uploadFile","uploadsContainerUri","headers","Headers","Slug","fileName","name","fileExtension","splitFileName","pop","createSlug","lang","response","status","get","uploadAllFiles","property","hasOwnProperty","createMethod","fieldsMapping","_dataModel$fieldsMapp","title","set","_dataModel$fieldsMapp2","create","_dataModel$create","_dataModel$create2","server","serverKeys","JSON","stringify","responseHeaders","resourceUri","updateMethod","deleteMethod","deleteManyMethod","message","prototype","window","atob","bind","t","String","n","c","charAt","fromCharCode","indexOf","decodeURIComponent","charCodeAt","toString","header","parse","fetchPodConfig","podKey","pod","token","localStorage","getItem","jwtDecode","webId","podUri","RegExp","fetchVoidEndpoints","fetchPromises","URL","result","error","RaDateTimeInput","groupReference","groupLabel","groupHeader","filterProperty","useQueryWithStore","payload","index","group","label","RaImageField","RaReferenceInput","reificationClass","flexFormClasses","hideInputStyles","ArrayInput","SimpleFormIterator","classes","className","TextInput","initialValue","fromEntries","fetchPodConfigPromise","fetchVoidEndpointsPromise","waitForVoidEndpoints","getMany","getManyReference","update","updateMany","deleteMany","options","has","fetchUtils","fetchJson"],"mappings":"65HAGMA,EAAsB,gBAAGC,IAAAA,OAAQC,IAAAA,OAAWC,kCAC5CF,MAAAA,SAAAA,EAASC,MACNE,MAAMC,QAAQJ,EAAOC,MACxBD,EAAOC,GAAU,CAACD,EAAOC,KAE3BD,EAAOC,GAAUD,EAAOC,GAAQI,KAAI,SAAAC,UAAKA,EAAE,QAAUA,EAAEC,IAAMD,MAExDE,gBAACC,yBAAsBT,OAAQA,EAAQC,OAAQA,GAAYC,KAGpEH,EAAoBW,aAAe,CACjCC,UAAU,OCXNC,EAAiB,gBAAGZ,IAAAA,OAAQC,IAAAA,OAAWC,kCACvCF,EAAOC,IACqB,WAA1BY,EAAOb,EAAOC,MAChBD,EAAOC,GAAUD,EAAOC,GAAQ,QAAUD,EAAOC,GAAQM,IAGtDC,gBAACM,oBAAiBd,OAAQA,EAAQC,OAAQA,GAAYC,KAG/DU,EAAeF,aAAe,CAC5BC,UAAU,OCINI,EAAgB,gBAAGC,IAAAA,SAAUhB,IAAAA,OAAQiB,IAAAA,OAAQhB,IAAAA,OAAWC,mDAC5BgB,gBAAzBC,OAAUC,cACjBC,aAAU,cACJrB,GAAUC,GAAUE,MAAMC,QAAQJ,MAAAA,SAAAA,EAASC,IAAU,KACjDqB,EAAetB,MAAAA,SAAAA,EAASC,GAAQgB,QAAO,SAAAM,OACvCC,GAAK,MACJ,IAAMC,KAAOR,EAAQ,KAClBS,EAAQH,EAAEE,GACZtB,MAAMC,QAAQsB,GACXA,EAAMC,SAASV,EAAOQ,MACzBD,GAAK,GAGHE,IAAUT,EAAOQ,KACnBD,GAAK,UAIJA,KAELI,OACC5B,GAGL4B,EAAU3B,GAAUqB,EAAaO,OAAS,EAAIP,OAAeQ,EAC7DV,EAAYQ,MAEb,CAAC5B,EAAQC,EAAQgB,IAGlBT,gCACGA,EAAMuB,SAAS1B,IAAIW,GAAU,SAACgB,EAAO1B,UAC7BE,EAAMyB,aAAaD,SACrB9B,OACHF,OAAQmB,EACRR,UAAU,EACVV,OAAAA,UClDJiC,EAAsB,SAAAC,OACpBC,EAAWC,qBAAmB,WAElC7B,gBAAC8B,2BACKH,GACJC,SAAUA,EACVG,OAAQ,SAAAb,UAEDA,GAIAvB,MAAMC,QAAQsB,KAAQA,EAAQ,CAACA,IAEhCS,EAAMI,SAAQb,EAAQS,EAAMI,OAAOb,IAEhCA,EAAMrB,KAAI,SAAAmC,SAAmB,WAAb3B,EAAO2B,GAAiBA,EAAEjC,IAAMiC,EAAE,OAASA,MAR/Cd,OCPrBe,EAA0BC,aAAW,CACzCC,KAAM,CACJC,QAAS,QAEXC,MAAO,CACLC,aAAc,UAIZC,EAAqBL,aAAW,CACpCM,KAAM,CACJJ,QAAS,UCdPK,EAAsB,SAACC,EAAKC,UACzBC,OAAOC,KAAKF,GAAaG,MAAK,SAAA7B,UACnC8B,QAAQC,IAAI,iBAAkBN,EAAKC,EAAY1B,IACxCyB,EAAIO,WAAWN,EAAY1B,GAAKiC,aCDrCC,EAAe,SAAAC,sDAAU,WAAOC,EAAYC,oHACxCX,EAAoDS,EAApDT,YAAaY,EAAuCH,EAAvCG,UAAWC,EAA4BJ,EAA5BI,WAAYC,EAAgBL,EAAhBK,YACtCC,EAAYH,EAAUF,yBAEN,IAAIM,yBAAkBN,qDAEtCO,EAAYnB,EAAoBa,EAAOvD,GAAI4C,YAEtBa,EAAWF,EAAOvD,GAAI,CAC/C8D,SAAUD,IAAmD,IAAtCjB,EAAYiB,GAAWE,iCADpCC,IAANC,MAGDjE,GAAKgE,EAAKhE,IAAMgE,EAAK,OAItBA,EAAK,cAAgBN,oCACVQ,EAAOC,QAAQH,EAAMN,WAAlCM,8BAIEL,EAAUS,yBAAVC,EAAgBC,WAAY,eACDX,EAAUS,yBAAVG,EAAgBD,2CAAlCE,UACLR,EAAKQ,KAAoB5E,MAAMC,QAAQmE,EAAKQ,MAC9CR,EAAKQ,GAAkB,CAACR,EAAKQ,6DAK5B,CAAER,KAAMA,yGClBXS,EAAwB,SAAAC,UAC5BA,EACGC,MAAM,KACN7E,KAAI,SAAA8E,UAAKA,EAAE,GAAGC,cAAgBD,EAAEE,MAAM,MACtCC,KAAK,KCdJC,EAAmB,gBAAGC,IAAAA,WAAsBvE,IAAV6C,OAAU7C,OAAUwE,IAAAA,YAAaC,IAAAA,WACnEC,EAAa,GAEb1E,IACEA,EAAO2E,GAAK3E,EAAO2E,EAAE/D,OAAS,IAChC8D,+HAKqC1E,EAAO2E,EAAEC,gGAKvC5E,EAAO2E,GAEhBxC,OAAOC,KAAKpC,GAAQ6E,SAAQ,SAAAb,MACtBhE,EAAOgE,GAAY,KACfc,EAAS9E,EAAOgE,GAAWxB,WAAW,mBAAcxC,EAAOgE,QAAgBhE,EAAOgE,GACxFU,iBAAqBV,cAAac,iBAKlCC,EDT6B,SAAAC,OAC/BC,EAAU,MAEVD,UACIE,EAAsBF,EAAWG,QAAO,SAACC,EAAKpB,UAtB/B,SAAnBqB,EAAoBC,EAAatB,OAAWuB,yDAAS,UACrDvB,EAAUtD,SAAS,KAAM,KACrB8E,EAAUxB,EAAUC,MAAM,UAChCqB,EAAYE,EAAQ,IAAMD,EAC1BF,EAAiBC,EAAaE,EAAQ,GAAIA,EAAQ,SAElDF,EAAYtB,GAAauB,SAEpBD,EAc6DD,CAAiBD,EAAKpB,KAAY,UAElE7B,OAAOsD,QAAQP,kBAAsB,iBAA3DlB,OAAWuB,OACfG,EAAU3B,EAAsBC,GAChC2B,EAA2B,SAAXJ,EAAoB,IAAMxB,EAAsBwB,GAGhEK,EAAsB,SAAXL,EAAoBvB,EAAYuB,EAC5CN,EAAQW,KAAWX,EAAQW,GAAY,IAE5CX,EAAQW,GAAUC,2BACZF,cAAiB3B,gBAAe0B,2BAChCA,gBAAaA,gBAAaA,uBAK7B,CACLI,UAAW3D,OAAO4D,OAAOd,GACtB7F,KAAI,SAAA4G,UAAkB7D,OAAO4D,OAAOC,GAAgB3B,KAAK,SACzDA,KAAK,MACR4B,MAAO9D,OAAO4D,OAAOd,GAClB7F,KAAI,SAAA4G,8BAAgC7D,OAAO4D,OAAOC,GAAgB3B,KAAK,eACvEA,KAAK,OClBe6B,CAAsB1B,yBC5B1B,SAAAC,UACdA,EAAWrF,KAAI,SAAA+G,0BAAsBA,EAASC,qBAAYD,EAASE,YAAQhC,KAAK,MD8BnFiC,CAAe7B,4DAGbM,EAAiBe,mHAISvB,EAAWnF,KAAI,SAAAmH,oBAAiBA,UAAclC,KAAK,8DAE7EK,qBACAK,EAAiBkB,2QEzCzB,IAAiBO,EAASC,EAATD,EAIHE,EAJYD,EAIN,WAElB,SAASE,EAAWC,GAClB,IAAIC,EAAc,GAClB,GAAwB,IAApBD,EAAShG,OAAgB,MAAO,GAEpC,GAA2B,iBAAhBgG,EAAS,GAClB,MAAM,IAAIE,UAAU,kCAAoCF,EAAS,IAInE,GAAIA,EAAS,GAAGG,MAAM,iBAAmBH,EAAShG,OAAS,EAAG,CAC5D,IAAIoG,EAAQJ,EAASK,QACrBL,EAAS,GAAKI,EAAQJ,EAAS,GAI7BA,EAAS,GAAGG,MAAM,gBACpBH,EAAS,GAAKA,EAAS,GAAGM,QAAQ,gBAAiB,UAEnDN,EAAS,GAAKA,EAAS,GAAGM,QAAQ,gBAAiB,SAGrD,IAAK,IAAI7H,EAAI,EAAGA,EAAIuH,EAAShG,OAAQvB,IAAK,CACxC,IAAI8H,EAAYP,EAASvH,GAEzB,GAAyB,iBAAd8H,EACT,MAAM,IAAIL,UAAU,kCAAoCK,GAGxC,KAAdA,IAEA9H,EAAI,IAEN8H,EAAYA,EAAUD,QAAQ,SAAU,KAIxCC,EAFE9H,EAAIuH,EAAShG,OAAS,EAEZuG,EAAUD,QAAQ,SAAU,IAG5BC,EAAUD,QAAQ,SAAU,KAG1CL,EAAYhB,KAAKsB,IAInB,IAAIC,EAAMP,EAAYxC,KAAK,KAOvBgD,GAHJD,EAAMA,EAAIF,QAAQ,kBAAmB,OAGrBjD,MAAM,KAGtB,OAFAmD,EAAMC,EAAMJ,SAAWI,EAAMzG,OAAS,EAAI,IAAK,IAAMyG,EAAMhD,KAAK,KAKlE,OAAO,WASL,OAAOsC,EANqB,iBAAjBW,UAAU,GACXA,UAAU,GAEV,GAAGlD,MAAMmD,KAAKD,cAtEWE,EAAOC,QAASD,UAAiBf,IAEjED,EAAY,QAAIC,OCDjBiB,EAA0B,SAACC,EAAOC,EAAS1F,OAC3CqC,EAAa,GACbsD,EAAqB,UACzB1F,OAAOC,KAAKF,GAAa2C,SAAQ,SAAAiD,GAC/B3F,OAAOC,KAAKF,EAAY4F,GAAMvD,YAAYM,SAAQ,SAAAkD,GAC3CH,KAAY1I,MAAMC,QAAQyI,GAAWA,EAAQlH,SAASqH,GAAQH,IAAYG,IAC7E5F,OAAOC,KAAKF,EAAY4F,GAAMvD,WAAWwD,IAAOlD,SAAQ,SAAAmD,GAClDL,EAAMjH,SAASsH,IACjB9F,EAAY4F,GAAMvD,WAAWwD,GAAMC,GAAM5I,KAAI,SAAA6I,OACrCC,EAAeC,EAAQjG,EAAY6F,GAAMtF,QAASwF,GAGnDJ,EAAmBnH,SAASwH,KAC/BL,EAAmBhC,KAAKqC,GAEnB3D,EAAWuD,KAAQvD,EAAWuD,GAAQ,IAC3CvD,EAAWuD,GAAMjC,KAAKqC,gBAQ7B3D,GC1BH6D,EAAgB,SAAAC,OAElBrD,EADEsD,EAAa,MAEbD,EAAO,WACQA,kCAAO,KAAfJ,UAELjD,EADEiD,EAAKvH,SAAS,KACHuH,EAAKhE,MAAM,KAAKsE,UAEhB,CAACN,GAEhBK,SACKA,GACAtD,EAAWG,QACZ,SAACG,EAAatB,eACXA,cACW,SACPsB,MAGP,2CAICgD,ICbLE,EAAgB,SAAA7F,sDAAU,WAAOC,EAAYC,gIAC3CX,EAAgES,EAAhET,YAAaa,EAAmDJ,EAAnDI,WAAYD,EAAuCH,EAAvCG,UAAW2B,EAA4B9B,EAA5B8B,WAAYzB,EAAgBL,EAAhBK,YAChDC,EAAYH,EAAUF,GAO1B2B,aAFEtB,EAAUS,2BAAMa,wBAActB,EAAUS,2BAAMa,WAAW3D,QAAS,YAEvDqC,EAAUS,yBAAV+E,EAAgBlE,WAEhBmD,EAAwBzE,EAAU0E,gBAAO1E,EAAUS,yBAAVgF,EAAgBd,QAAS1F,GAG3EyG,gBACQ3F,UACHC,EAAU0E,eAGT,UACPS,YAAcnF,EAAUS,yBAAVkF,EAAgBpE,cAG7BqE,EAAsB1G,OAAOC,KAAKmC,GAAYnF,KAAI,SAAA+D,UACtD,IAAI2F,SAAQ,SAACC,EAASC,SACdC,EAAc3E,EAAiB,CACnCC,WAAYA,EAAWpB,GACvBN,cAAaA,OAAQ7C,wBAAaiD,EAAUS,yBAAVwF,EAAgBlJ,QAAW6C,EAAO7C,UACpEwE,YAAavB,EAAUuB,YACvBC,WAAAA,IAGF1B,EAAWb,EAAYiB,GAAWgG,eAAgB,CAC9CC,OAAQ,OACRC,KAAMJ,EACN7F,SAA+C,IAAtClB,EAAYiB,GAAWE,aAEjCiG,MAAK,gBAAG/F,IAAAA,YAEAC,EAAOmF,MAAMpF,EAAMoF,EAAO,CAAEY,WAAW,OAE/CD,MAAK,SAAAE,GACJT,EAAQS,EAAY,WAAa,cAE5B,SAAAC,UAAKT,EAAOS,qBAKLX,QAAQY,IAAIb,aAA5Bc,SAKmB,KAFvBA,QAAaC,QAAOC,gBAASF,KAEjB/I,iDACH,CAAE0C,KAAM,GAAIwG,MAAO,mBAGtBC,EAAaJ,EAAQvK,KAAI,SAAA4K,UAC3BA,EAAK1K,GAAK0K,EAAK1K,IAAM0K,EAAK,OACnBA,KAGLnH,EAAOoH,OACTF,EAAaA,EAAWE,MAAK,SAACC,EAAGC,UAC3BD,EAAErH,EAAOoH,KAAKG,SAAUD,EAAEtH,EAAOoH,KAAKG,SACd,QAAtBvH,EAAOoH,KAAKI,MACPH,EAAErH,EAAOoH,KAAKG,OAAOE,cAAcH,EAAEtH,EAAOoH,KAAKG,QAEjDD,EAAEtH,EAAOoH,KAAKG,OAAOE,cAAcJ,EAAErH,EAAOoH,KAAKG,aAO5DvH,EAAO0H,aACTR,EAAaA,EAAW3F,OACrBvB,EAAO0H,WAAWC,KAAO,GAAK3H,EAAO0H,WAAWE,QACjD5H,EAAO0H,WAAWC,KAAO3H,EAAO0H,WAAWE,4BAIxC,CAACnH,KAAMyG,EAAYD,MAAOH,EAAQ/I,8GC3FvC8J,EAAgB,SAAA/H,sDAAU,WAAOC,EAAYC,mGACzC8H,EAA0BhI,EAA1BgI,sBAEJZ,EAAa,OAEFlH,EAAO+H,qEACpBtL,EAAmB,WAAdM,EADEN,WACuBA,EAAG,OAASA,qBAGrBuL,EAAOlI,EAAPkI,CAAejI,EAAY,CAAEtD,GAAAA,YAA1CgE,SACNyG,EAAWlE,KAAKvC,qDAKZqH,GAEFZ,EAAWlE,KAAK,CAAEvG,GAAAA,4KAOjB,CAAEgE,KAAMyG,oICxBXe,EAAyB,SAAAnI,sDAAU,WAAOC,EAAYC,0FAC1DA,EAAO7C,cAAc6C,EAAO7C,gBAAS6C,EAAOkI,OAASlI,EAAOvD,cAC/C0L,EAAQrI,EAARqI,CAAgBnI,+ICQlBoI,EAAS,SAAAC,UAAKA,GAAKA,EAAEC,SAAWD,EAAEC,mBAAmBC,MAE5DC,8CAAa,WAAOF,EAASxI,yGACVA,EAAOI,WAAWJ,EAAO2I,oBAAqB,CACnElC,OAAQ,OACRC,KAAM8B,EACNI,QAAS,IAAIC,QAAQ,CAInBC,MApB8BC,EAoBHP,EAAQQ,KAnBnCC,OAAAA,EACAC,OAAAA,EADAD,EAAgB,GAChBC,EAAgBH,EAASzH,MAAM,KAC/B4H,EAAcjL,OAAS,IACzBgL,EAAgBC,EAAcC,MAC9BJ,EAAWG,EAAcxH,KAAK,MAEzB0H,EAAWL,EAAU,CAAEM,KAAM,OAAU,IAAMJ,kBAchCT,EAAQnD,mBAIJ,OAZlBiE,UAYOC,gDACJD,EAASV,QAAQY,IAAI,8CA1BI,IAAAT,EAC9BE,EACAC,mEAgCAO,8CAAiB,WAAOrN,EAAQ4D,8FAC/BA,EAAO2I,0CAA2B,IAAIpI,MAAM,4FAE5BnE,oDAAZsN,cACHtN,EAAOuN,eAAeD,wBACpBnN,MAAMC,QAAQJ,EAAOsN,qBACdhN,EAAI,cAAGA,EAAIN,EAAOsN,GAAUzL,6BAC/BqK,EAAOlM,EAAOsN,GAAUhN,sCACEgM,EAAWtM,EAAOsN,GAAUhN,GAAG8L,QAASxI,WAApE5D,EAAOsN,GAAUhN,kBAFwBA,uDAMzC4L,EAAOlM,EAAOsN,sCACShB,EAAWtM,EAAOsN,GAAUlB,QAASxI,WAA9D5D,EAAOsN,kEAKRtN,uGCjDHwN,EAAe,SAAA5J,sDAAU,WAAOC,EAAYC,8HACxCX,EAAoDS,EAApDT,YAAaY,EAAuCH,EAAvCG,UAAWC,EAA4BJ,EAA5BI,WAAYC,EAAgBL,EAAhBK,YACtCC,EAAYH,EAAUF,GAItB2I,EAAU,IAAIC,mBAEhBvI,EAAUuJ,kCAAVC,EAAyBC,QAC3BnB,EAAQoB,IACN,OACA9J,EAAOS,eAAKL,EAAUuJ,kCAAVI,EAAyBF,oBAKrCzJ,EAAU4J,2BAAVC,EAAkBvG,4BACpB2B,YAAejF,EAAU4J,2BAAVE,EAAkBxG,UACjCpD,EAAYnB,EAAoBkG,EAAchG,8BAE9CiB,aAAYF,EAAU4J,6BAAQG,SAAU7K,OAAOC,KAAKO,EAAOT,aAAaG,MAAK,SAAA7B,UAA2C,IAApCmC,EAAOT,YAAY1B,qCAChF,IAAI0C,MAAM,6FAE3BqB,EAAamD,EAAwBzE,EAAU0E,MAAO,CAACxE,GAAYjB,IAEnE+K,EAAa9K,OAAOC,KAAKmC,KAEU,IAAtB0I,EAAWrM,8BAAqB,IAAIsC,wCAAiCgK,KAAKC,UAAUlK,EAAU0E,mCAA0BxE,iBACvI8J,EAAWrM,OAAS,GAAK2D,EAAW0I,EAAW,IAAIrM,OAAS,0BAAU,IAAIsC,4DAAqDgK,KAAKC,UAAUlK,EAAU0E,6BAAoBxE,YAChL+E,EAAe3D,EAAW0I,EAAW,IAAI,4BAMAlK,EAAWmF,EAAc,CAClEkB,OAAQ,OACRmC,QAAAA,EACAlC,KAAM6D,KAAKC,wBACGnK,UACHC,EAAU0E,OAChB9E,EAAOS,OAEZF,SAA+C,IAAtClB,EAAYiB,GAAWE,qCARjB+J,IAAT7B,QAYF8B,EAAcD,EAAgBjB,IAAI,sBAC3BtB,EAAOlI,EAAPkI,CAAejI,EAAY,CAAEtD,GAAI+N,kJCnD1CC,EAAe,SAAA3K,sDAAU,WAAOC,EAAYC,kGACxCE,EAA4BJ,EAA5BI,WAAYC,EAAgBL,EAAhBK,qBAGAoJ,EAAevJ,EAAOS,KAAMX,iBAAhDE,EAAOS,qBAEDP,EAAWF,EAAOvD,GAAI,CAC1B8J,OAAQ,MACRC,KAAM6D,KAAKC,wBACGnK,GACTH,EAAOS,yCAIP,CAAEA,KAAMT,EAAOS,2GChBlBiK,EAAe,SAAA5K,sDAAU,WAAOC,EAAYC,gGACxCE,EAAeJ,EAAfI,oBAEFA,EAAWF,EAAOvD,GAAI,CAC1B8J,OAAQ,2CAGH,CAAE9F,KAAM,CAAEhE,GAAIuD,EAAOvD,0GCPxBkO,EAAmB,SAAA7K,sDAAU,WAAOC,EAAYC,iGAC5CE,EAAeJ,EAAfI,WACJ6H,EAAM,OAEK/H,EAAO+H,qEAAbtL,6BAECyD,EAAWzD,EAAI,CACnB8J,OAAQ,mBAEVwB,EAAI/E,KAAKvG,6NAMN,CAAEgE,KAAMsH,oICfjB,SAASnB,EAAEA,GAAG/C,KAAK+G,QAAQhE,EAAEA,EAAEiE,UAAU,IAAIxK,MAAMuG,EAAEiE,UAAU/B,KAAK,wBAAwB,IAAIrL,EAAE,oBAAoBqN,QAAQA,OAAOC,MAAMD,OAAOC,KAAKC,KAAKF,SAAS,SAASrN,GAAG,IAAIwN,EAAEC,OAAOzN,GAAG4G,QAAQ,MAAM,IAAI,GAAG4G,EAAElN,OAAO,GAAG,EAAE,MAAM,IAAI6I,EAAE,qEAAqE,IAAI,IAAIuE,EAAE9C,EAAEhB,EAAE,EAAE7K,EAAE,EAAE4O,EAAE,GAAG/C,EAAE4C,EAAEI,OAAO7O,MAAM6L,IAAI8C,EAAE9D,EAAE,EAAE,GAAG8D,EAAE9C,EAAEA,EAAEhB,IAAI,GAAG+D,GAAGF,OAAOI,aAAa,IAAIH,KAAK,EAAE9D,EAAE,IAAI,EAAEgB,EAAE,oEAAoEkD,QAAQlD,GAAG,OAAO+C,GAAG,SAASH,EAAErE,GAAG,IAAIqE,EAAErE,EAAEvC,QAAQ,KAAK,KAAKA,QAAQ,KAAK,KAAK,OAAO4G,EAAElN,OAAO,GAAG,KAAK,EAAE,MAAM,KAAK,EAAEkN,GAAG,KAAK,MAAM,KAAK,EAAEA,GAAG,IAAI,MAAM,QAAQ,KAAK,4BAA4B,IAAI,OAAO,SAASrE,GAAG,OAAO4E,mBAAmB/N,EAAEmJ,GAAGvC,QAAQ,iBAAiBuC,EAAEnJ,GAAG,IAAIwN,EAAExN,EAAEgO,WAAW,GAAGC,SAAS,IAAIpK,cAAc,OAAO2J,EAAElN,OAAO,IAAIkN,EAAE,IAAIA,GAAG,IAAIA,MAA3J,CAAkKA,GAAG,MAAMrE,GAAG,OAAOnJ,EAAEwN,IAAI,SAASE,EAAEvE,GAAG/C,KAAK+G,QAAQhE,EAAE,SAASyB,EAAEzB,EAAEnJ,GAAG,GAAG,iBAAiBmJ,EAAE,MAAM,IAAIuE,EAAE,2BAA2B,IAAI9C,GAAE,KAAM5K,EAAEA,GAAG,IAAIkO,OAAO,EAAE,EAAE,IAAI,OAAOtB,KAAKuB,MAAMX,EAAErE,EAAExF,MAAM,KAAKiH,KAAK,MAAMzB,GAAG,MAAM,IAAIuE,EAAE,4BAA4BvE,EAAEgE,UAAUO,EAAEN,UAAU,IAAIxK,MAAM8K,EAAEN,UAAU/B,KAAK,oBCExoC,IAEM+C,8CAAiB,WAAM/L,kGACrBgM,EAASxM,OAAOC,KAAKO,EAAOT,aAAaG,MAAK,SAAA7B,UAAuC,IAAhCmC,EAAOT,YAAY1B,GAAKoO,UAI3EC,EAAQC,aAAaC,QAAQ,cAIfC,EAAUH,GAApBI,IAAAA,MAGFC,EAA6BD,EAdFlI,MAAM,IAAIoI,mBAAmB,GAiB9DxM,EAAOT,YAAYyM,GAAQhD,KAAO,SAClChJ,EAAOT,YAAYyM,GAAQlM,QAAUyM,EACrCvM,EAAOT,YAAYyM,GAAQxF,eAAiB+F,EAAS,4GCrBrDE,8CAAqB,WAAMzM,sGACzB0M,EAAgBlN,OAAO4D,OAAOpD,EAAOT,aACxClC,QAAO,SAAAgN,UAAyB,IAAfA,EAAO4B,OACxBxP,KAAI,SAAA4N,UACHrK,EAAOI,WAAW,IAAIuM,IAAI,oBAAqBtC,EAAOvK,UACnD6G,MAAK,SAAAiG,SAAW,CAAEjM,KAAMiM,EAAOhM,gBACzB,SAAAkG,MAAwB,MAAbA,EAAEyC,aAA0B,CAAEsD,MAAO/F,SAAoBA,iBAG3DX,QAAQY,IAAI2F,UAA5B1F,aAEaA,0CAENrG,0JCPO,SAAApC,UACpB3B,gBAACkQ,qBAAoBvO,GAAOI,OAAQ,SAAAb,UAASA,GAASA,EAAMyG,QAAQ,IAAK,KAAKA,QAAQ,IAAK,iEC6D7D,gBAC9BnH,IAAAA,SACA2P,IAAAA,eACAC,IAAAA,WACAC,IAAAA,YACAC,IAAAA,eACG5Q,iFAEKqE,EAASwM,oBAAkB,CACjC9H,KAAM,UACN7G,SAAUuO,EACVK,QAAS,KAHHzM,YAON/D,gCACG+D,MAAAA,SAAAA,EAAMlE,KAAI,SAACkE,EAAM0M,OACZhQ,EAAS,UACbA,EAAO6P,GAAkBvM,EAAKhE,GAE5BC,gCACGqQ,GAAeA,SAAiB3Q,OAAYgR,MAAO3M,KACpD/D,gBAACO,OAAkBb,GAAYe,OAAQA,EAAQkQ,MAAO5M,EAAKqM,KACxD5P,4BCxFI,gBAAGhB,IAAAA,OAAQC,IAAAA,OAAWC,iCAEjB,iBAAXF,IAAqBA,OAAYC,EAASD,IAC9CQ,gBAAC4Q,gBAAapR,OAAQA,EAAQC,OAAQA,GAAYC,iHCHpC,SAAAiC,OACfC,EAAWC,qBAAmB,WAElC7B,gBAAC6Q,sBACKlP,GACJC,SAAUA,EACVG,OAAQ,SAAAb,UAEDA,GAEDS,EAAMI,SAAQb,EAAQS,EAAMI,OAAOb,IAEf,WAAjBb,EAAOa,GAAqBA,EAAMnB,IAAMmB,EAAM,OAASA,GAJ3CA,qCvBQG,SAAAS,OACpBmP,EAA8CnP,EAA9CmP,iBAA+BpR,GAAeiC,EAA5BnB,WAA4BmB,oCAChDoP,EAAkB9O,IAClB+O,EAAkBzO,WAGtBvC,gBAACiR,aAAevR,EACdM,gBAACkR,sBAAmBC,QAAS,CAAEhP,KAAM4O,EAAgB5O,OAClDnC,EAAMuB,SAAS1B,IAAI8B,EAAMnB,UAAU,SAACgB,EAAO1B,UACnCE,EAAMyB,aAAaD,EAAO,CAC/B4P,UAAWL,EAAgB1O,WAG/BrC,gBAACqR,aAAUD,UAAWJ,EAAgBxO,KAAM/C,OAAO,OAAO6R,aAAcR,4EwBrB3D,SAAA1N,GAGdA,EAAOK,cAAaL,EAAOK,YAAcb,OAAO2O,YAAYnO,EAAO8B,WAAWrF,KAAI,SAAA8L,SAAK,CAACA,EAAE9E,OAAQ8E,EAAE7E,UACpG1D,EAAOgI,wBAAuBhI,EAAOgI,uBAAwB,OAE5DoG,EAAwBrC,EAAe/L,GACvCqO,EAA4B5B,EAAmBzM,GAE/CsO,EAAuB,SAAA7H,qCAAU,6HAC/B2H,yBACAC,yBACO5H,4GAGR,CACL4B,QAASiG,EAAqBzI,EAAc7F,IAC5CkI,OAAQoG,EAAqBvO,EAAaC,IAC1CuO,QAASD,EAAqBvG,EAAc/H,IAC5CwO,iBAAkBF,EAAqBnG,EAAuBnI,IAC9DkK,OAAQoE,EAAqB1E,EAAa5J,IAC1CyO,OAAQH,EAAqB3D,EAAa3K,IAC1C0O,WAAY,iBACJ,IAAInO,MAAM,6CAEV+N,EAAqB1D,EAAa5K,IAC1C2O,WAAYL,EAAqBzD,EAAiB7K,yBCnCnC,SAAC0D,OAAKkL,yDAAU,UAC5BA,EAAQhG,UAASgG,EAAQhG,QAAU,IAAIC,SAEpC+F,EAAQnI,YACT,WACA,YACA,MACEmI,EAAQhG,QAAQiG,IAAI,WAAWD,EAAQhG,QAAQoB,IAAI,SAAU,uBAC7D4E,EAAQhG,QAAQiG,IAAI,iBAAiBD,EAAQhG,QAAQoB,IAAI,eAAgB,iCAG3E,mBAGA,cAEE4E,EAAQhG,QAAQiG,IAAI,WAAWD,EAAQhG,QAAQoB,IAAI,SAAU,2BAIjE4E,EAAQnO,QAAU,KACfyL,EAAQC,aAAaC,QAAQ,SAC/BF,GAAO0C,EAAQhG,QAAQoB,IAAI,iCAA2BkC,WAGrD4C,aAAWC,UAAUrL,EAAKkL"}